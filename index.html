<!DOCTYPE html>
<html>

<head>
    <title>Awesome-Graphs</title>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            position: absolute;
            width: 100%;
            height: 100%;
        }

        #network {
            width: 100%;
            height: 100%;
        }

        ul,
        li,
        ol {
            padding: 0;
            margin: 0;
            list-style: none;
        }

        #node-detail {
            display: none;
            left: 50%;
            width: max-content;
            top: 50px;
            transform: translateX(-50%);
            position: absolute;
            border: 0;
            border-radius: 5px;
            background-color: transparent;
            padding: 10px;
            z-index: 1000;
            text-align: center;
        }


        input {
            width: 200px;
            height: 40px;
            line-height: 40px;
            font-size: 16px;
            border: 1px solid #CCC;
            border-radius: 5px 0 0 5px;
            padding-left: 10px;
        }

        button {
            width: 80px;
            height: 44px;
            line-height: 44px;
            position: relative;
            top: 1px;
            left: -6px;
            border-radius: 0 5px 5px 0;
            border: 1px solid #CCC;
            cursor: pointer;
        }

        #context-menu {
            display: none;
            position: absolute;
            background-color: #e2e3e4;
            z-index: 1000;
            padding: 5px 10px;
            border-radius: 5px;
        }

        #context-menu ul li {
            font-size: 14px;
            line-height: 26px;
            cursor: pointer;
            background-color: #e2e3e4;
            margin-bottom: 2px;
            border-bottom: 1px solid #cacbcc;
            padding: 0 30px 0 0;
        }

        #context-menu ul li:last-child {
            margin-bottom: 0;
            border-bottom-width: 0;
        }

        #context-menu ul li:hover {
            background-color: #bbb;
        }

    </style>
</head>

<body>
    <div style="position: absolute; top: 30px;left: 30px;z-index: 2;">
        <input type="text" id="searchInput" placeholder="Graph System Name">
        <button id="searchButton">Search</button>
    </div>
    <div id="network"></div>
    <div id="node-detail"></div>
    <div id="context-menu">
        <ul>
            <li id="reference-network">Reference Network</li>
            <li id="citation-network">Citation Network</li>
            <li id="direct-neighbours">Direct Neighbours</li>
        </ul>
    </div>
    <script type="text/javascript">
        var direction = 'from'
        var baseUrl = 'https://github.com/TuGraph-family/Awesome-Graphs/blob/master/papers/'
        var input = document.getElementById('searchInput');
        var contextMenu = document.getElementById('context-menu');
        let isNodeSelected = false;

        // create nodes
        var nodes = new vis.DataSet([
            {id: 'A1', _paper: 'A1: A Distributed In-Memory Graph Database'},
            {id: 'ASPIRE', _paper: 'ASPIRE: Exploiting Asynchronous Parallelism in Iterative Algorithms using a Relaxed Consistency based DSM'},
            {id: 'AeonG', _paper: 'AeonG: An Efficient Built-in Temporal Support in Graph Databases (Extended Version)'},
            {id: 'AsynGraph', _paper: 'AsynGraph: Maximizing Data Parallelism for Efficient Iterative Graph Processing on GPUs'},
            {id: 'Auxo', _paper: 'Auxo: A Temporal Graph Management System'},
            {id: 'BG3', _paper: 'BG3: A Cost Effective and I/O Efficient Graph Database in ByteDance'},
            {id: 'Blaze', _paper: 'Blaze: Fast Graph Processing on Fast SSDs'},
            {id: 'BlitzG', _paper: 'BlitzG: Exploiting high-bandwidth networks for fast graph processing'},
            {id: 'Blogel', _paper: 'Blogel: A Block-Centric Framework for Distributed Computation on Real-World Graphs'},
            {id: 'ByteGraph', _paper: 'ByteGraph: A High-Performance Distributed Graph Database in ByteDance'},
            {id: 'CGgraph', _paper: 'CGgraph: An Ultra-fast Graph Processing System on Modern Commodity CPU-GPU Co-processor'},
            {id: 'CGraph', _paper: 'CGraph: A correlations-aware approach for efficient concurrent iterative graph processing'},
            {id: 'CLIP', _paper: 'CLIP: A Disk I/O Focused Parallel Out-of-core Graph Processing System'},
            {id: 'CSMqGraph', _paper: 'CSMqGraph: Coarse-Grained and Multi-external-storage Multi-queue I/O Management for Graph Computing'},
            {id: 'Chaos', _paper: 'Chaos: Scale-out Graph Processing from Secondary Storage'},
            {id: 'Chronograph', _paper: 'Chronograph: A Distributed Processing Platform for Online and Batch Computations on Event-sourced Graphs'},
            {id: 'Chronos', _paper: 'Chronos: A Graph Engine for Temporal Graph Analysis'},
            {id: 'CoRAL', _paper: 'CoRAL: Confined Recovery in Distributed Asynchronous Graph Processing'},
            {id: 'CommonGraph', _paper: 'CommonGraph: Graph Analytics on Evolving Data'},
            {id: 'CuSha', _paper: 'CuSha: Vertex-Centric Graph Processing on GPUs'},
            {id: 'Cymbalo', _paper: 'Cymbalo: An Efficient Graph Processing Framework for Machine Learning'},
            {id: 'D2Graph', _paper: 'D2Graph: An Efficient and Unified Out-of-Core Graph Computing Model'},
            {id: 'DD-Graph', _paper: 'DD-Graph: A Highly Cost-Effective Distributed Disk-based Graph-Processing Framework'},
            {id: 'DFOGraph', _paper: 'DFOGraph: An I/O- and Communication-Efficient System for Distributed Fully-out-of-Core Graph Processing'},
            {id: 'DZiG', _paper: 'DZiG: Sparsity-Aware Incremental Processing of Streaming Graphs'},
            {id: 'DepGraph', _paper: 'DepGraph: A Dependency-Driven Accelerator for Efficient Iterative Graph Processing'},
            {id: 'DiGraph', _paper: 'DiGraph: An Efficient Path-based Iterative Directed Graph Processing System on Multiple GPUs'},
            {id: 'Differential dataflow', _paper: 'Differential dataflow'},
            {id: 'Distributed GraphLab', _paper: 'Distributed GraphLab: A Framework for Machine Learning and Data Mining in the Cloud'},
            {id: 'DiterGraph', _paper: 'DiterGraph: Toward I/O-Efficient Incremental Computation over Large Graphs with Billion Edges'},
            {id: 'DynamoGraph', _paper: 'DynamoGraph: A Distributed System for Large-scale, Temporal Graph Processing, its Implementation and First Observations'},
            {id: 'EGraph', _paper: 'EGraph: Efficient concurrent GPU-based dynamic graph processing'},
            {id: 'EPGraph', _paper: 'EPGraph: An Efficient Graph Computing Model in Persistent Memory System'},
            {id: 'EmptyHeaded', _paper: 'EmptyHeaded: A Relational Engine for Graph Processing'},
            {id: 'FBSGraph', _paper: 'FBSGraph: Accelerating Asynchronous Graph Processing via Forward and Backward Sweeping'},
            {id: 'FENNEL', _paper: 'FENNEL: Streaming Graph Partitioning for Massive Scale Graphs'},
            {id: 'FOG', _paper: 'FOG: A Fast Out-of-Core Graph Processing Framework'},
            {id: 'Fargraph+', _paper: 'Fargraph+: Excavating the parallelism of graph processing workload on RDMA-based far memory system'},
            {id: 'FlashGraph', _paper: 'FlashGraph: Processing Billion-Node Graphs on an Array of Commodity SSDs'},
            {id: 'ForeGraph', _paper: 'ForeGraph: Exploring Large-scale Graph Processing on Multi-FPGA Architecture'},
            {id: 'Frog', _paper: 'Frog: Asynchronous graph processing on GPU with hybrid coloring model'},
            {id: 'G-Store', _paper: 'G-Store: High-Performance Graph Store for Trillion-Edge Processing'},
            {id: 'G-Tran', _paper: 'G-Tran: A High Performance Distributed Graph Database with a Decentralized Architecture'},
            {id: 'GBASE', _paper: 'GBASE: A Scalable and General Graph Management System'},
            {id: 'GFlink', _paper: 'GFlink: An In-Memory Computing Architecture on Heterogeneous CPU-GPU Clusters for Big Data'},
            {id: 'GGraph', _paper: 'GGraph: An Efficient Structure-Aware Approach for Iterative Graph Processing'},
            {id: 'GPOP', _paper: 'GPOP: A scalable cache- and memory-efficient framework for Graph Processing Over Partitions'},
            {id: 'GPS', _paper: 'GPS: A Graph Processing System'},
            {id: 'GRAM', _paper: 'GRAM: Scaling Graph Computation to the Trillions'},
            {id: 'GRAPE', _paper: 'GRAPE: Parallelizing Sequential Graph Computations'},
            {id: 'GRE', _paper: 'GRE: A Graph Runtime Engine for Large-Scale Distributed Graph-Parallel Applications'},
            {id: 'GStream', _paper: 'GStream: A Graph Streaming Processing Method for Large-scale Graphs on GPUs'},
            {id: 'Garaph', _paper: 'Garaph: Efficient GPU-accelerated Graph Processing on a Single Machine with Balanced Replication'},
            {id: 'GasCL', _paper: 'GasCL: A Vertex-Centric Graph Model for GPUs'},
            {id: 'GeaFlow', _paper: 'GeaFlow: A Graph Extended and Accelerated Dataflow System'},
            {id: 'Gemini', _paper: 'Gemini: A Computation-Centric Distributed Graph Processing System'},
            {id: 'Giraph Unchained', _paper: 'Giraph Unchained: Barrierless Asynchronous Parallel Execution in Pregel-like Graph Processing Systems'},
            {id: 'Giraph', _website: 'http://giraph.apache.org', _type: 'db'},
            {id: 'GoFFish', _paper: 'GoFFish: A Sub-graph Centric Framework for Large-Scale Graph Analytics'},
            {id: 'GraPU', _paper: 'GraPU: Accelerate Streaming Graph Analysis through Preprocessing Buffered Updates'},
            {id: 'GraVF', _paper: 'GraVF: A Vertex-Centric Distributed Graph Processing Framework on FPGAs'},
            {id: 'Gradoop', _paper: 'Analyzing Temporal Graphs with Gradoop'},
            {id: 'GrapH', _paper: 'GrapH: Traffic-Aware Graph Processing'},
            {id: 'Graph Database', _type: 'db'},
            {id: 'Graph3S', _paper: 'Graph3S: A Simple, Speedy and Scalable Distributed Graph Processing System'},
            {id: 'GraphA', _paper: 'GraphA: An efficient ReRAM-based architecture to accelerate large scale graph processing'},
            {id: 'GraphABCD', _paper: 'GraphABCD: Scaling Out Graph Analytics with Asynchronous Block Coordinate Descent'},
            {id: 'GraphBolt', _paper: 'GraphBolt: Dependency-Driven Synchronous Processing of Streaming Graphs'},
            {id: 'GraphBuilder', _paper: 'GraphBuilder: Scalable Graph ETL Framework'},
            {id: 'GraphCP', _paper: 'GraphCP: An I/O-Efficient Concurrent Graph Processing Framework'},
            {id: 'GraphCage', _paper: 'GraphCage: Cache Aware Graph Processing on GPUs'},
            {id: 'GraphChi', _paper: 'GraphChi: Large-Scale Graph Computation on Just a PC'},
            {id: 'GraphD', _paper: 'GraphD: Distributed Vertex-Centric Graph Processing Beyond the Memory Limit'},
            {id: 'GraphDuo', _paper: 'GraphDuo: A Dual-Model Graph Processing Framework'},
            {id: 'GraphFly', _paper: 'GraphFly: Efficient Asynchronous Streaming Graphs Processing via Dependency-Flow'},
            {id: 'GraphGen', _paper: 'GraphGen: An FPGA Framework for Vertex-Centric Graph Computation'},
            {id: 'GraphGrind', _paper: 'GraphGrind: addressing load imbalance of graph partitioning'},
            {id: 'GraphH(1)', label: 'GraphH(1)', _paper: 'GraphH(1): High Performance Big Graph Analytics in Small Clusters'},
            {id: 'GraphH(2)', label: 'GraphH(2)', _paper: 'GraphH(2): A Processing-in-Memory Architecture for Large-scale Graph Processing'},
            {id: 'GraphIA', _paper: 'GraphIA: An In-situ Accelerator for Large-scale Graph Processing'},
            {id: 'GraphIn', _paper: 'GraphIn: An Online High Performance Incremental Graph Processing Framework'},
            {id: 'GraphLab', _paper: 'GraphLab: A New Framework For Parallel Machine Learning'},
            {id: 'GraphM', _paper: 'GraphM: An Efficient Storage System for High Throughput of Concurrent Graph Processing'},
            {id: 'GraphMP(1)', label: 'GraphMP(1)', _paper: 'GraphMP(1): An Efficient Semi-External-Memory Big Graph Processing System on a Single Machine'},
            {id: 'GraphMP(2)', label: 'GraphMP(2)', _paper: 'GraphMP(2): I/O-Efficient Big Graph Analytics on a Single Commodity Machine'},
            {id: 'GraphMap', _paper: 'GraphMap: scalable iterative graph processing using NoSQL'},
            {id: 'GraphMat', _paper: 'GraphMat: High performance graph analytics made productive'},
            {id: 'GraphOne', _paper: 'GraphOne: A Data Store for Real-time Analytics on Evolving Graphs'},
            {id: 'GraphP', _paper: 'GraphP: Reducing Communication for PIM-based Graph Processing with Efficient Data Partition'},
            {id: 'GraphPEG', _paper: 'GraphPEG: Accelerating Graph Processing on GPUs'},
            {id: 'GraphPIM', _paper: 'GraphPIM: Enabling Instruction-Level PIM Offloading in Graph Computing Frameworks'},
            {id: 'GraphPhi', _paper: 'GraphPhi: Efficient Parallel Graph Processing on Emerging Throughput-oriented Architectures'},
            {id: 'GraphPulse', _paper: 'GraphPulse: An Event-Driven Hardware Accelerator for Asynchronous Graph Processing'},
            {id: 'GraphQ', _paper: 'GraphQ: Graph Query Processing with Abstraction Refinement'},
            {id: 'GraphR', _paper: 'GraphR: Accelerating Graph Processing Using ReRAM'},
            {id: 'GraphReduce', _paper: 'GraphReduce: Processing Large-Scale Graphs on Accelerator-Based Systems'},
            {id: 'GraphSD', _paper: 'GraphSD: A State and Dependency aware Out-of-Core Graph Processing System'},
            {id: 'GraphScSh', _paper: 'GraphScSh: Efficient I/O Scheduling and Graph Sharing for Concurrent Graph Processing'},
            {id: 'GraphScope', _paper: 'GraphScope: A Unified Engine For Big Graph Processing'},
            {id: 'GraphTides', _paper: 'GraphTides: A Framework for Evaluating Stream-based Graph Processing Platforms'},
            {id: 'GraphTinker', _paper: 'GraphTinker: A High Performance Data Structure for Dynamic Graph Processing'},
            {id: 'GraphTune', _paper: 'GraphTune: An Efficient Dependency-Aware Substrate to Alleviate Irregularity in Concurrent Graph Processing'},
            {id: 'GraphTwist', _paper: 'GraphTwist: Fast Iterative Graph Computation with Two-tier Optimizations'},
            {id: 'GraphX', _paper: 'GraphX: A Resilient Distributed Graph System on Spark'},
            {id: 'GraphZ', _paper: 'GraphZ: Improving the Performance of Large-Scale Graph Analytics on Small-Scale Machines'},
            {id: 'Graphene', _paper: 'Graphene: Fine-Grained IO Management for Graph Computing'},
            {id: 'Graphflow', _paper: 'Graphflow: An Active Graph Database'},
            {id: 'Graphie', _paper: 'Graphie: Large-Scale Asynchronous Graph Traversals on Just a GPU'},
            {id: 'Graspan', _paper: 'Graspan: A Single-machine Disk-based Graph System for Interprocedural Static Analyses of Large-scale Systems Code'},
            {id: 'Grasper', _paper: 'Grasper: A High Performance Distributed System for OLAP on Property Graphs'},
            {id: 'GridGraph', _paper: 'GridGraph: Large-Scale Graph Processing on a Single Machine Using 2-Level Hierarchical Partitioning'},
            {id: 'Groute', _paper: 'Groute: Asynchronous Multi-GPU Programming Model with Applications to Large-scale Graph Processing'},
            {id: 'HGraph', _paper: 'HGraph: I/O-efficient Distributed and Iterative Graph Computing by Hybrid Pushing/Pulling'},
            {id: 'HPGraph', _paper: 'HPGraph: A High Parallel Graph Processing System Based on Flash Array'},
            {id: 'HUS-Graph', _paper: 'HUS-Graph: I/O-Efficient Out-of-Core Graph Processing with Hybrid Update Strategy'},
            {id: 'HaLoop', _paper: 'HaLoop: Efficient Iterative Data Processing on Large Clusters'},
            {id: 'HipG', _paper: 'HipG: Parallel Processing of Large-Scale Graphs'},
            {id: 'HitGraph', _paper: 'HitGraph: High-throughput Graph Processing Framework on FPGA'},
            {id: 'HotGraph', _paper: 'HotGraph: Efficient Asynchronous Processing for Real-World Graphs'},
            {id: 'HyTGraph', _paper: 'HyTGraph: GPU-Accelerated Graph Processing with Hybrid Transfer Management'},
            {id: 'HyVE', _paper: 'HyVE: Hybrid Vertex-Edge Memory Hierarchy for Energy-Efficient Graph Processing'},
            {id: 'HybridGraph', _paper: 'HybridGraph: Hybrid Pulling:Pushing for I:O-Efficient Distributed and Iterative Graph Computing'},
            {id: 'ImmortalGraph', _paper: 'ImmortalGraph: A System for Storage and Analysis of Temporal Graphs'},
            {id: 'JanusGraph', _website: 'http://janusgraph.org', _type: 'db'},
            {id: 'JetStream', _paper: 'JetStream: Graph Analytics on Streaming Data with Event-Driven Hardware Accelerator'},
            {id: 'KickStarter', _paper: 'KickStarter: Fast and Accurate Computations on Streaming Graphs via Trimmed Approximations'},
            {id: 'Kineograph', _paper: 'Kineograph: Taking the Pulse of a Fast-Changing and Connected World'},
            {id: 'L-PowerGraph', _paper: 'L-PowerGraph: a lightweight distributed graph-parallel communication mechanism'},
            {id: 'LCC-Graph', _paper: 'LCC-Graph: A High-Performance Graph-Processing Framework with Low Communication Costs'},
            {id: 'LFGraph', _paper: 'LFGraph: Simple and Fast Distributed Graph Analytics'},
            {id: 'LLAMA', _paper: 'LLAMA: Efficient Graph Analytics Using Large Multiversioned Arrays.'},
            {id: 'LOSC', _paper: 'LOSC: Efficient Out-of-Core Graph Processing with Locality-optimized Subgraph Construction'},
            {id: 'LSGraph', _paper: 'LSGraph: A Locality-centric High-performance Streaming Graph Engine'},
            {id: 'LargeGraph', _paper: 'LargeGraph: An Efficient Dependency-Aware GPU-Accelerated Large-Scale Graph Processing'},
            {id: 'LazyGraph', _paper: 'LazyGraph: Lazy Data Coherency for Replicas in Distributed Graph-Parallel Computation'},
            {id: 'LightGraph', _paper: 'LightGraph: Lighten Communication in Distributed Graph-Parallel Processing'},
            {id: 'Ligra', _paper: 'Ligra: A Lightweight Graph Processing Framework for Shared Memory'},
            {id: 'LiveGraph', _paper: 'LiveGraph: A Transactional Graph Storage System with Purely Sequential Adjacency List Scans'},
            {id: 'Lumos', _paper: 'Lumos: Dependency-Driven Disk-based Graph Processing'},
            {id: 'MMap', _paper: 'MMap: Fast Billion-Scale Graph Computation on a PC via Memory Mapping'},
            {id: 'MOCgraph', _paper: 'MOCgraph: Scalable Distributed Graph Processing Using Message Online Computing'},
            {id: 'MOSAIC', _paper: 'MOSAIC: Processing a Trillion-Edge Graph on a Single Machine'},
            {id: 'Maiter', _paper: 'Maiter: An Asynchronous Graph Processing Framework for Delta-based Accumulative Iterative Computation'},
            {id: 'MapGraph', _paper: 'MapGraph: A High Level API for Fast Development of High Performance Graph Analytics on GPUs'},
            {id: 'Medusa', _paper: 'Medusa: Simplified Graph Processing on GPUs'},
            {id: 'Mizan', _paper: 'Mizan: A System for Dynamic Load Balancing in Large-scale Graph Processing'},
            {id: 'MultiLogVC', _paper: 'MultiLogVC: Efficient Out-of-Core Graph Processing Framework for Flash Storage'},
            {id: 'NGraph', _paper: 'NGraph: Parallel Graph Processing in Hybrid Memory Systems'},
            {id: 'NPGraph', _paper: 'NPGraph: An Efficient Graph Computing Model in NUMA-Based Persistent Memory Systems'},
            {id: 'NScale', _paper: 'NScale: Neighborhood-centric Analytics on Large Graphs'},
            {id: 'NXgraph', _paper: 'NXgraph: An Efficient Graph Processing System on a Single Machine* '},
            {id: 'Naiad', _paper: 'Naiad: A Timely Dataflow System'},
            {id: 'Neo4j', _website: 'https://neo4j.com', _type: 'db'},
            {id: 'PGAbB', _paper: 'PGAbB: A Block-Based Graph Processing Framework for Heterogeneous Platforms'},
            {id: 'PGX.D', label: 'PGX.D', _paper: 'PGX.D: A Fast Distributed Graph Processing Engine'},
            {id: 'PartitionedVC', _paper: 'PartitionedVC: Partitioned External Memory Graph Analytics Framework for SSDs'},
            {id: 'PathGraph', _paper: 'PathGraph: A Path Centric Graph Processing System'},
            {id: 'Pimiento', _paper: 'Pimiento: A Vertex-Centric Graph-Processing Framework on a Single Machine'},
            {id: 'PowerGraph', _paper: 'PowerGraph: Distributed Graph-Parallel Computation on Natural Graphs'},
            {id: 'PowerLyra', _paper: 'PowerLyra: Differentiated Graph Computation and Partitioning on Skewed Graphs'},
            {id: 'PrIter', _paper: 'PrIter: A Distributed Framework for Prioritized Iterative Computations'},
            {id: 'Pregel', _paper: 'Pregel: A System for Large-Scale Graph Processing'},
            {id: 'Pregelix', _paper: 'Pregelix: Big(ger) Graph Analytics on A Dataflow Engine'},
            {id: 'Quegel', _paper: 'Quegel: A General-Purpose Query-Centric Framework for Querying Big Graphs'},
            {id: 'Raphtory', _paper: 'Raphtory: Streaming Analysis Of Distributed Temporal Graphs'},
            {id: 'ReGraph', _paper: 'ReGraph: A Graph Processing Framework that Alternately Shrinks and Repartitions the Graph'},
            {id: 'Ringo', _paper: 'Ringo: Interactive Graph Analytics on Big-Memory Machines'},
            {id: 'RisGraph', _paper: 'RisGraph: A Real-Time Streaming System for Evolving Graphs to Support Sub-millisecond Per-update Analysis at Millions Ops/s'},
            {id: 'SGraph', _paper: 'SGraph: A Distributed Streaming System for Processing Big Graphs'},
            {id: 'STINGER', _paper: 'STINGER: High Performance Data Structure for Streaming Graphs'},
            {id: 'SaGraph', _paper: 'SaGraph: A Similarity-aware Hardware Accelerator for Temporal Graph Processing'},
            {id: 'ScalaGraph', _paper: 'ScalaGraph: A Scalable Accelerator for Massively Parallel Graph Processing'},
            {id: 'ScaleG', _paper: 'ScaleG: A Distributed Disk-based System for Vertex-centric Graph Processing'},
            {id: 'Scaph', _paper: 'Scaph: Scalable GPU-Accelerated Graph Processing with Value-Driven Differential Scheduling'},
            {id: 'Seraph', _paper: 'Seraph: an Efficient, Low-cost System for Concurrent Graph Processing'},
            {id: 'ShenTu', _paper: 'ShenTu: Processing Multi-Trillion Edge Graphs on Millions of Cores in Seconds'},
            {id: 'Subway', _paper: 'Subway: Minimizing Data Transfer during Out-of-GPU-Memory Graph Processing'},
            {id: 'SympleGraph', _paper: 'SympleGraph: Distributed Graph Processing with Precise Loop-Carried Dependency Guarantee'},
            {id: 'TDGraph', _paper: 'TDGraph: A Topology-Driven Accelerator for High-Performance Streaming Graph Processing'},
            {id: 'TIDE', _paper: 'TIDE: Dynamic Interaction Graphs with Probabilistic Edge Decay'},
            {id: 'TeGraph', _paper: 'TeGraph: A Novel General-Purpose Temporal Graph Computing Engine'},
            {id: 'TeGraph+', _paper: 'TeGraph+: Scalable Temporal Graph Processing Enabling Flexible Edge Modifications'},
            {id: 'Tegra', _paper: 'Tegra: Efficient Ad-Hoc Analytics on Evolving Graphs'},
            {id: 'ThunderGP', _paper: 'ThunderGP: HLS-based graph processing framework on FPGAs'},
            {id: 'TigerGraph', _paper: 'TigerGraph: A Native MPP Graph Database', _website: 'https://www.tigergraph.com', _type: 'db'},
            {id: 'Tigr', _paper: 'Tigr: Transforming Irregular Graphs for GPU-Friendly Graph Processing'},
            {id: 'Tornado', _paper: 'Tornado: A System For Real-Time Iterative Analysis Over Evolving Data'},
            {id: 'Trinity', _paper: 'Trinity: A Distributed Graph Engine on a Memory Cloud'},
            {id: 'Tripoline', _paper: 'Tripoline: Generalized Incremental Graph Processing via Graph Triangle Inequality'},
            {id: 'TuGraph', _website: 'https://tugraph.tech', _type: 'db'},
            {id: 'TurboGraph', _paper: 'TurboGraph: A Fast Parallel Graph Engine Handling Billion-scale Graphs in a Single PC'},
            {id: 'VENUS', _paper: 'VENUS: A System for Streamlined Graph Computation on a Single PC'},
            {id: 'VGL', _paper: 'VGL: a high-performance graph processing framework for the NEC SX-Aurora TSUBASA vector architecture'},
            {id: 'VeilGraph', _paper: 'VeilGraph: Approximating Graph Streams'},
            {id: 'Version Traveler', _paper: 'Version Traveler: Fast and Memory-Efficient Version Switching in Graph Processing Systems'},
            {id: 'Weaver', _paper: 'Weaver: A High-Performance, Transactional Graph Database Based on Refinable Timestamps'},
            {id: 'WolfGraph', _paper: 'WolfGraph: the Edge-Centric graph processing on GPU'},
            {id: 'Wonderland', _paper: 'Wonderland: A Novel Abstraction-Based Out-Of-Core Graph Processing System'},
            {id: 'X-Stream', _paper: 'X-Stream: Edge-centric Graph Processing using Streaming Partitions'},
            {id: 'XPGraph', _paper: 'XPGraph: XPline-Friendly Persistent Memory Graph Stores for Large-Scale Evolving Graphs'},
            {id: 'Zorro', _paper: 'Zorro: Zero-Cost Reactive Failure Recovery in Distributed Graph Processing'},
            {id: 'faimGraph', _paper: 'faimGraph: High Performance Management of Fully-Dynamic Graphs under tight Memory Constraints on the GPU'},
            {id: 'iGraph', _paper: 'iGraph: an incremental data processing system for dynamic graph'},
            {id: 'iMapReduce', _paper: 'iMapReduce: A Distributed Computing Framework for Iterative Computation'},
            {id: 'iPregel', _paper: 'iPregel: A Combiner-Based In-Memory Shared Memory Vertex-Centric Framework'},
            {id: 'iTurboGraph', _paper: 'iTurboGraph: Scaling and Automating Incremental Graph Analytics'},
            {id: 'xDGP', _paper: 'xDGP: A Dynamic Graph Processing System with Adaptive Partitioning'},
        ]);

        // create edges
        var edges = new vis.DataSet([
            {from: 'A1', to: 'Trinity'},
            {from: 'ASPIRE', to: 'Ligra'},
            {from: 'AeonG', to: 'Auxo'},
            {from: 'AeonG', to: 'G-Tran'},
            {from: 'AeonG', to: 'Gradoop'},
            {from: 'AeonG', to: 'Graphflow'},
            {from: 'AeonG', to: 'LiveGraph'},
            {from: 'AsynGraph', to: 'DiGraph'},
            {from: 'AsynGraph', to: 'Garaph'},
            {from: 'AsynGraph', to: 'Maiter'},
            {from: 'AsynGraph', to: 'Tigr'},
            {from: 'Auxo', to: 'Chronos'},
            {from: 'BG3', to: 'ByteGraph'},
            {from: 'Blaze', to: 'Lumos'},
            {from: 'BlitzG', to: 'DD-Graph'},
            {from: 'BlitzG', to: 'GRAM'},
            {from: 'BlitzG', to: 'GoFFish'},
            {from: 'BlitzG', to: 'MOCgraph'},
            {from: 'BlitzG', to: 'Seraph'},
            {from: 'Blogel', to: 'Giraph'},
            {from: 'Blogel', to: 'PowerGraph'},
            {from: 'ByteGraph', to: 'G-Tran'},
            {from: 'ByteGraph', to: 'Graphflow'},
            {from: 'ByteGraph', to: 'LiveGraph'},
            {from: 'CGgraph', to: 'GPOP'},
            {from: 'CGgraph', to: 'HyTGraph'},
            {from: 'CGgraph', to: 'LargeGraph'},
            {from: 'CGraph', to: 'GRAM'},
            {from: 'CGraph', to: 'HUS-Graph'},
            {from: 'CGraph', to: 'MOSAIC'},
            {from: 'CGraph', to: 'NXgraph'},
            {from: 'CGraph', to: 'Seraph'},
            {from: 'CGraph', to: 'Version Traveler'},
            {from: 'CSMqGraph', to: 'Graphene'},
            {from: 'CSMqGraph', to: 'HGraph'},
            {from: 'CSMqGraph', to: 'NXgraph'},
            {from: 'Chaos', to: 'GRAM', _bidirectional: true},
            {from: 'Chaos', to: 'GridGraph'},
            {from: 'Chronograph', to: 'ImmortalGraph'},
            {from: 'Chronos', to: 'Ligra'},
            {from: 'Chronos', to: 'Naiad'},
            {from: 'CLIP', to: 'Graphene'},
            {from: 'CoRAL', to: 'ASPIRE'},
            {from: 'CoRAL', to: 'Trinity'},
            {from: 'CommonGraph', to: 'GraphOne'},
            {from: 'CommonGraph', to: 'JetStream'},
            {from: 'CommonGraph', to: 'TDGraph'},
            {from: 'CommonGraph', to: 'Tripoline'},
            {from: 'CuSha', to: 'Medusa'},
            {from: 'Cymbalo', to: 'GraphD'},
            {from: 'Cymbalo', to: 'Wonderland'},
            {from: 'D2Graph', to: 'GraphMP(2)'},
            {from: 'D2Graph', to: 'Graphene'},
            {from: 'D2Graph', to: 'MMap'},
            {from: 'D2Graph', to: 'WolfGraph'},
            {from: 'DD-Graph', to: 'Chaos'},
            {from: 'DFOGraph', to: 'HGraph'},
            {from: 'DFOGraph', to: 'HybridGraph'},
            {from: 'DFOGraph', to: 'Lumos'},
            {from: 'DZiG', to: 'GraphOne'},
            {from: 'DZiG', to: 'ImmortalGraph'},
            {from: 'DZiG', to: 'Lumos'},
            {from: 'DepGraph', to: 'AsynGraph'},
            {from: 'DepGraph', to: 'GGraph'},
            {from: 'DepGraph', to: 'GraphABCD'},
            {from: 'DepGraph', to: 'GraphM'},
            {from: 'DepGraph', to: 'GraphPIM'},
            {from: 'DepGraph', to: 'GraphR'},
            {from: 'DepGraph', to: 'NGraph'},
            {from: 'DiGraph', to: 'FBSGraph'},
            {from: 'DiGraph', to: 'GraphGrind'},
            {from: 'DiGraph', to: 'Graphie'},
            {from: 'DiGraph', to: 'HotGraph'},
            {from: 'DiGraph', to: 'NXgraph'},
            {from: 'DiGraph', to: 'ReGraph'},
            {from: 'DiGraph', to: 'Wonderland'},
            {from: 'Differential dataflow', to: 'Pregel'},
            {from: 'Differential dataflow', to: 'iMapReduce'},
            {from: 'Distributed GraphLab', to: 'PrIter'},
            {from: 'DiterGraph', to: 'HybridGraph'},
            {from: 'DynamoGraph', to: 'ImmortalGraph'},
            {from: 'EGraph', to: 'DZiG'},
            {from: 'EGraph', to: 'DiGraph'},
            {from: 'EGraph', to: 'GraphTinker'},
            {from: 'EPGraph', to: 'D2Graph'},
            {from: 'EPGraph', to: 'DFOGraph'},
            {from: 'EPGraph', to: 'HyVE'},
            {from: 'EmptyHeaded', to: 'GraphX'},
            {from: 'EmptyHeaded', to: 'Ligra'},
            {from: 'FBSGraph', to: 'CoRAL'},
            {from: 'FBSGraph', to: 'PowerLyra'},
            {from: 'FBSGraph', to: 'Pregelix'},
            {from: 'Fargraph+', to: 'GraphCP'},
            {from: 'Fargraph+', to: 'HUS-Graph'},
            {from: 'FENNEL', to: 'PowerGraph'},
            {from: 'FOG', to: 'FlashGraph'},
            {from: 'FOG', to: 'GridGraph'},
            {from: 'FlashGraph', to: 'Maiter'},
            {from: 'FlashGraph', to: 'TurboGraph'},
            {from: 'ForeGraph', to: 'Gemini'},
            {from: 'ForeGraph', to: 'GraVF'},
            {from: 'ForeGraph', to: 'GraphGen'},
            {from: 'ForeGraph', to: 'NXgraph'},
            {from: 'Frog', to: 'CuSha'},
            {from: 'Frog', to: 'Ligra'},
            {from: 'Frog', to: 'X-Stream'},
            {from: 'G-Store', to: 'Chaos'},
            {from: 'G-Tran', to: 'A1'},
            {from: 'G-Tran', to: 'PowerLyra'},
            {from: 'G-Tran', to: 'SGraph'},
            {from: 'G-Tran', to: 'TigerGraph'},
            {from: 'G-Tran', to: 'Weaver'},
            {from: 'GBASE', to: 'Pregel'},
            {from: 'GFlink', to: 'Medusa'},
            {from: 'GGraph', to: 'FBSGraph'},
            {from: 'GGraph', to: 'GrapH'},
            {from: 'GGraph', to: 'GraphA'},
            {from: 'GGraph', to: 'GraphM'},
            {from: 'GGraph', to: 'HGraph'},
            {from: 'GGraph', to: 'HUS-Graph'},
            {from: 'GPOP', to: 'GoFFish'},
            {from: 'GPOP', to: 'GridGraph'},
            {from: 'GPS', to: 'iMapReduce'},
            {from: 'Gradoop', to: 'Raphtory'},
            {from: 'GRAM', to: 'PowerLyra'},
            {from: 'GRAPE', to: 'Blogel'},
            {from: 'GStream', to: 'CuSha'},
            {from: 'GStream', to: 'Trinity'},
            {from: 'GStream', to: 'TurboGraph'},
            {from: 'Garaph', to: 'Chaos'},
            {from: 'Garaph', to: 'CuSha'},
            {from: 'Garaph', to: 'GStream'},
            {from: 'Garaph', to: 'Gemini'},
            {from: 'GasCL', to: 'Medusa'},
            {from: 'GasCL', to: 'X-Stream'},
            {from: 'GeaFlow', to: 'ByteGraph'},
            {from: 'GeaFlow', to: 'RisGraph'},
            {from: 'GeaFlow', to: 'TuGraph'},
            {from: 'GeaFlow', to: 'iGraph'},
            {from: 'Gemini', to: 'GridGraph'},
            {from: 'Gemini', to: 'LazyGraph'},
            {from: 'Giraph Unchained', to: 'Pregelix'},
            {from: 'Giraph', to: 'Graph Database'},
            {from: 'GoFFish', to: 'Trinity'},
            {from: 'GraPU', to: 'Gemini'},
            {from: 'GraPU', to: 'GoFFish'},
            {from: 'GraPU', to: 'KickStarter'},
            {from: 'GraPU', to: 'Tigr'},
            {from: 'GraPU', to: 'Version Traveler'},
            {from: 'GraPU', to: 'Wonderland'},
            {from: 'GraPU', to: 'Zorro'},
            {from: 'GraVF', to: 'GraphGen'},
            {from: 'GrapH', to: 'GridGraph'},
            {from: 'Graph3S', to: 'Graphene'},
            {from: 'Graph3S', to: 'HybridGraph'},
            {from: 'GraphA', to: 'GFlink'},
            {from: 'GraphA', to: 'GraphR'},
            {from: 'GraphABCD', to: 'CLIP'},
            {from: 'GraphABCD', to: 'ForeGraph'},
            {from: 'GraphABCD', to: 'GraphP'},
            {from: 'GraphABCD', to: 'Tigr'},
            {from: 'GraphABCD', to: 'Wonderland'},
            {from: 'GraphBolt', to: 'GraphIn'},
            {from: 'GraphBolt', to: 'KickStarter'},
            {from: 'GraphBuilder', to: 'Trinity'},
            {from: 'GraphCP', to: 'CGraph'},
            {from: 'GraphCP', to: 'GraphM'},
            {from: 'GraphCP', to: 'GraphZ'},
            {from: 'GraphCP', to: 'Seraph'},
            {from: 'GraphCP', to: 'VENUS'},
            {from: 'GraphCage', to: 'GraphMat'},
            {from: 'GraphCage', to: 'GraphPhi'},
            {from: 'GraphChi', to: 'GPS'},
            {from: 'GraphChi', to: 'PowerGraph', _bidirectional: true},
            {from: 'GraphD', to: 'Blogel'},
            {from: 'GraphD', to: 'G-Store'},
            {from: 'GraphD', to: 'Pregelix'},
            {from: 'GraphD', to: 'VENUS'},
            {from: 'GraphDuo', to: 'GrapH'},
            {from: 'GraphDuo', to: 'GraphD'},
            {from: 'GraphDuo', to: 'GraphIn'},
            {from: 'GraphDuo', to: 'GraphP'},
            {from: 'GraphDuo', to: 'Wonderland'},
            {from: 'GraphFly', to: 'LiveGraph'},
            {from: 'GraphFly', to: 'ScalaGraph'},
            {from: 'GraphFly', to: 'Tripoline'},
            {from: 'GraphGen', to: 'GraphChi'},
            {from: 'GraphGrind', to: 'Ligra'},
            {from: 'GraphH(1)', to: 'Chaos'},
            {from: 'GraphH(1)', to: 'MOCgraph'},
            {from: 'GraphH(2)', to: 'Garaph'},
            {from: 'GraphH(2)', to: 'GraphPIM'},
            {from: 'GraphH(2)', to: 'MOCgraph'},
            {from: 'GraphH(2)', to: 'NXgraph'},
            {from: 'GraphIA', to: 'Gemini'},
            {from: 'GraphIA', to: 'GraphH(2)'},
            {from: 'GraphIA', to: 'GraphP'},
            {from: 'GraphIA', to: 'NXgraph'},
            {from: 'GraphIn', to: 'GraphMat'},
            {from: 'GraphIn', to: 'GraphReduce'},
            {from: 'GraphIn', to: 'STINGER'},
            {from: 'GraphLab', to: 'Pregel'},
            {from: 'GraphM', to: 'DiGraph'},
            {from: 'GraphM', to: 'GraphR'},
            {from: 'GraphM', to: 'Lumos'},
            {from: 'GraphMP(1)', to: 'GraphD'},
            {from: 'GraphMP(1)', to: 'GraphH(1)'},
            {from: 'GraphMP(1)', to: 'MOSAIC'},
            {from: 'GraphMP(2)', to: 'GraphMP(1)'},
            {from: 'GraphMap', to: 'DiGraph'},
            {from: 'GraphMap', to: 'GraphD'},
            {from: 'GraphMap', to: 'GraphTwist'},
            {from: 'GraphMap', to: 'Pregelix'},
            {from: 'GraphMat', to: 'GraphX'},
            {from: 'GraphMat', to: 'MapGraph'},
            {from: 'GraphOne', to: 'GBASE'},
            {from: 'GraphOne', to: 'GraPU'},
            {from: 'GraphOne', to: 'GraphBolt'},
            {from: 'GraphOne', to: 'GraphD'},
            {from: 'GraphOne', to: 'Graphene'},
            {from: 'GraphOne', to: 'MOSAIC'},
            {from: 'GraphOne', to: 'TIDE'},
            {from: 'GraphP', to: 'GraphPIM'},
            {from: 'GraphP', to: 'GridGraph'},
            {from: 'GraphPEG', to: 'DiGraph'},
            {from: 'GraphPEG', to: 'GraphCage'},
            {from: 'GraphPEG', to: 'Tigr'},
            {from: 'GraphPIM', to: 'GraphChi'},
            {from: 'GraphPhi', to: 'GraphReduce'},
            {from: 'GraphPhi', to: 'Graphie'},
            {from: 'GraphPulse', to: 'FBSGraph'},
            {from: 'GraphPulse', to: 'GraphPIM'},
            {from: 'GraphPulse', to: 'Maiter'},
            {from: 'GraphQ', to: 'X-Stream'},
            {from: 'GraphR', to: 'GraphPIM'},
            {from: 'GraphR', to: 'GridGraph'},
            {from: 'GraphReduce', to: 'CuSha'},
            {from: 'GraphReduce', to: 'MapGraph'},
            {from: 'GraphReduce', to: 'X-Stream'},
            {from: 'GraphSD', to: 'Giraph Unchained'},
            {from: 'GraphSD', to: 'GraphZ'},
            {from: 'GraphSD', to: 'Lumos'},
            {from: 'GraphSD', to: 'MultiLogVC'},
            {from: 'GraphScSh', to: 'CGraph'},
            {from: 'GraphScSh', to: 'HGraph'},
            {from: 'GraphScope', to: 'A1'},
            {from: 'GraphScope', to: 'EmptyHeaded'},
            {from: 'GraphScope', to: 'FENNEL'},
            {from: 'GraphScope', to: 'Gemini'},
            {from: 'GraphTides', to: 'Chronograph'},
            {from: 'GraphTides', to: 'GoFFish'},
            {from: 'GraphTides', to: 'KickStarter'},
            {from: 'GraphTides', to: 'Weaver'},
            {from: 'GraphTinker', to: 'GraphIn'},
            {from: 'GraphTune', to: 'CGraph'},
            {from: 'GraphTune', to: 'Giraph Unchained'},
            {from: 'GraphTune', to: 'GraphM'},
            {from: 'GraphTwist', to: 'GraphX'},
            {from: 'GraphTwist', to: 'TurboGraph'},
            {from: 'GraphX', to: 'PowerGraph'},
            {from: 'GraphZ', to: 'Gemini'},
            {from: 'Graphene', to: 'Chaos'},
            {from: 'Graphene', to: 'GRE'},
            {from: 'Graphene', to: 'Maiter'},
            {from: 'Graphene', to: 'Wonderland'},
            {from: 'Graphflow', to: 'Neo4j'},
            {from: 'Graphie', to: 'PathGraph'},
            {from: 'Graphie', to: 'PowerLyra'},
            {from: 'Graspan', to: 'ASPIRE'},
            {from: 'Graspan', to: 'GridGraph'},
            {from: 'Grasper', to: 'GraphD'},
            {from: 'GRE', to: 'Mizan'},
            {from: 'GRE', to: 'X-Stream'},
            {from: 'GridGraph', to: 'FlashGraph'},
            {from: 'GridGraph', to: 'GraphQ', _bidirectional: true},
            {from: 'GridGraph', to: 'LightGraph'},
            {from: 'GridGraph', to: 'MMap'},
            {from: 'GridGraph', to: 'PowerLyra'},
            {from: 'Groute', to: 'Graphie'},
            {from: 'HGraph', to: 'Blogel'},
            {from: 'HGraph', to: 'GBASE'},
            {from: 'HGraph', to: 'GRE'},
            {from: 'HGraph', to: 'LFGraph'},
            {from: 'HGraph', to: 'Pregelix'},
            {from: 'HGraph', to: 'Seraph'},
            {from: 'HPGraph', to: 'MMap'},
            {from: 'HUS-Graph', to: 'BlitzG'},
            {from: 'HUS-Graph', to: 'Gemini'},
            {from: 'HUS-Graph', to: 'Graphene'},
            {from: 'HUS-Graph', to: 'LCC-Graph'},
            {from: 'HipG', to: 'Pregel'},
            {from: 'HitGraph', to: 'GraphMat'},
            {from: 'HitGraph', to: 'Graphie'},
            {from: 'HitGraph', to: 'HyVE'},
            {from: 'HitGraph', to: 'ThunderGP'},
            {from: 'HotGraph', to: 'GridGraph'},
            {from: 'HyTGraph', to: 'DiGraph'},
            {from: 'HyTGraph', to: 'Scaph'},
            {from: 'HyTGraph', to: 'Subway'},
            {from: 'HyVE', to: 'GraphR'},
            {from: 'HyVE', to: 'NXgraph'},
            {from: 'HybridGraph', to: 'GraphD'},
            {from: 'HybridGraph', to: 'GRE'},
            {from: 'ImmortalGraph', to: 'PowerLyra'},
            {from: 'JanusGraph', to: 'Graph Database'},
            {from: 'JetStream', to: 'ForeGraph'},
            {from: 'JetStream', to: 'GraphIn'},
            {from: 'JetStream', to: 'GraphP'},
            {from: 'JetStream', to: 'GraphPulse'},
            {from: 'JetStream', to: 'Tripoline'},
            {from: 'JetStream', to: 'Version Traveler'},
            {from: 'KickStarter', to: 'Chaos'},
            {from: 'KickStarter', to: 'Graspan'},
            {from: 'KickStarter', to: 'STINGER'},
            {from: 'KickStarter', to: 'Tornado'},
            {from: 'Kineograph', to: 'HaLoop'},
            {from: 'Kineograph', to: 'Neo4j'},
            {from: 'Kineograph', to: 'Pregel'},
            {from: 'L-PowerGraph', to: 'GraphD'},
            {from: 'L-PowerGraph', to: 'GrapH'},
            {from: 'LCC-Graph', to: 'Giraph Unchained'},
            {from: 'LCC-Graph', to: 'X-Stream'},
            {from: 'LFGraph', to: 'Trinity'},
            {from: 'LLAMA', to: 'Chronos'},
            {from: 'LLAMA', to: 'TurboGraph'},
            {from: 'LOSC', to: 'Gemini'},
            {from: 'LOSC', to: 'LCC-Graph'},
            {from: 'LSGraph', to: 'DepGraph'},
            {from: 'LSGraph', to: 'GraphPulse'},
            {from: 'LSGraph', to: 'LiveGraph'},
            {from: 'LSGraph', to: 'Tripoline'},
            {from: 'LargeGraph', to: 'DepGraph'},
            {from: 'LazyGraph', to: 'Frog'},
            {from: 'LazyGraph', to: 'GRAM'},
            {from: 'LazyGraph', to: 'LLAMA'},
            {from: 'LazyGraph', to: 'Medusa'},
            {from: 'LazyGraph', to: 'NScale'},
            {from: 'LazyGraph', to: 'PGX.D'},
            {from: 'LightGraph', to: 'Ligra'},
            {from: 'LightGraph', to: 'TurboGraph'},
            {from: 'Ligra', to: 'Giraph'},
            {from: 'Ligra', to: 'GraphChi'},
            {from: 'LiveGraph', to: 'GraphOne'},
            {from: 'LiveGraph', to: 'ImmortalGraph'},
            {from: 'LiveGraph', to: 'Weaver'},
            {from: 'Lumos', to: 'Garaph'},
            {from: 'Lumos', to: 'GraphBolt'},
            {from: 'Lumos', to: 'Graphene'},
            {from: 'Lumos', to: 'MOSAIC'},
            {from: 'MMap', to: 'TurboGraph'},
            {from: 'MMap', to: 'X-Stream'},
            {from: 'Maiter', to: 'PowerGraph'},
            {from: 'MapGraph', to: 'PowerGraph'},
            {from: 'Medusa', to: 'GraphChi'},
            {from: 'Mizan', to: 'HipG'},
            {from: 'Mizan', to: 'Trinity'},
            {from: 'MOCgraph', to: 'Mizan'},
            {from: 'MOCgraph', to: 'TurboGraph'},
            {from: 'MOSAIC', to: 'G-Store'},
            {from: 'MOSAIC', to: 'GraphReduce'},
            {from: 'MultiLogVC', to: 'Wonderland'},
            {from: 'NGraph', to: 'GraphGrind'},
            {from: 'NGraph', to: 'Seraph'},
            {from: 'NPGraph', to: 'EPGraph'},
            {from: 'NPGraph', to: 'GraphMP(2)'},
            {from: 'NPGraph', to: 'XPGraph'},
            {from: 'NScale', to: 'Trinity'},
            {from: 'Naiad', to: 'Differential dataflow'},
            {from: 'Naiad', to: 'GraphX'},
            {from: 'Neo4j', to: 'Graph Database'},
            {from: 'NXgraph', to: 'GBASE'},
            {from: 'NXgraph', to: 'GridGraph'},
            {from: 'NXgraph', to: 'HipG'},
            {from: 'NXgraph', to: 'MMap'},
            {from: 'PGAbB', to: 'GBASE'},
            {from: 'PGAbB', to: 'Garaph'},
            {from: 'PGX.D', to: 'Distributed GraphLab'},
            {from: 'PGX.D', to: 'GraphX'},
            {from: 'PGX.D', to: 'STINGER'},
            {from: 'PartitionedVC', to: 'GraphMP(1)'},
            {from: 'PartitionedVC', to: 'Lumos'},
            {from: 'PathGraph', to: 'Medusa'},
            {from: 'Pimiento', to: 'FOG'},
            {from: 'Pimiento', to: 'Gemini'},
            {from: 'Pimiento', to: 'NXgraph'},
            {from: 'Pimiento', to: 'VENUS'},
            {from: 'PowerGraph', to: 'Distributed GraphLab'},
            {from: 'PowerGraph', to: 'Kineograph'},
            {from: 'PowerLyra', to: 'Blogel'},
            {from: 'PowerLyra', to: 'Chronos', _bidirectional: true},
            {from: 'PowerLyra', to: 'GraphBuilder'},
            {from: 'PowerLyra', to: 'LFGraph'},
            {from: 'PowerLyra', to: 'Mizan'},
            {from: 'PowerLyra', to: 'X-Stream'},
            {from: 'PrIter', to: 'GraphLab'},
            {from: 'Pregelix', to: 'Trinity'},
            {from: 'Quegel', to: 'Blogel'},
            {from: 'Quegel', to: 'GraphX'},
            {from: 'Quegel', to: 'Trinity'},
            {from: 'Raphtory', to: 'GraphTides'},
            {from: 'ReGraph', to: 'Gemini'},
            {from: 'ReGraph', to: 'GoFFish'},
            {from: 'ReGraph', to: 'HitGraph'},
            {from: 'Ringo', to: 'TurboGraph'},
            {from: 'RisGraph', to: 'GraphOne'},
            {from: 'RisGraph', to: 'ImmortalGraph'},
            {from: 'RisGraph', to: 'Lumos'},
            {from: 'SGraph', to: 'Giraph'},
            {from: 'SGraph', to: 'GraphBuilder'},
            {from: 'SaGraph', to: 'EGraph'},
            {from: 'SaGraph', to: 'ScalaGraph'},
            {from: 'ScalaGraph', to: 'GraphABCD'},
            {from: 'ScalaGraph', to: 'GraphPulse'},
            {from: 'ScalaGraph', to: 'Scaph'},
            {from: 'ScalaGraph', to: 'Subway'},
            {from: 'ScalaGraph', to: 'ThunderGP'},
            {from: 'ScaleG', to: 'GraphD'},
            {from: 'ScaleG', to: 'HGraph'},
            {from: 'ScaleG', to: 'Medusa'},
            {from: 'ScaleG', to: 'NXgraph'},
            {from: 'Scaph', to: 'GraphPhi'},
            {from: 'Scaph', to: 'Lumos'},
            {from: 'Seraph', to: 'Trinity'},
            {from: 'ShenTu', to: 'Gemini'},
            {from: 'ShenTu', to: 'Graphene'},
            {from: 'ShenTu', to: 'MOSAIC'},
            {from: 'Subway', to: 'Garaph'},
            {from: 'Subway', to: 'Graphie'},
            {from: 'SympleGraph', to: 'Lumos'},
            {from: 'TDGraph', to: 'DepGraph'},
            {from: 'TIDE', to: 'GraphX'},
            {from: 'TIDE', to: 'Trinity'},
            {from: 'TeGraph', to: 'Auxo'},
            {from: 'TeGraph', to: 'DynamoGraph'},
            {from: 'TeGraph', to: 'GraphTides'},
            {from: 'TeGraph', to: 'LiveGraph'},
            {from: 'TeGraph', to: 'Lumos'},
            {from: 'TeGraph+', to: 'Blaze'},
            {from: 'TeGraph+', to: 'CommonGraph'},
            {from: 'TeGraph+', to: 'GraphScope'},
            {from: 'TeGraph+', to: 'Graphflow'},
            {from: 'TeGraph+', to: 'SaGraph'},
            {from: 'TeGraph+', to: 'TeGraph'},
            {from: 'Tegra', to: 'GraphOne'},
            {from: 'Tegra', to: 'GraphP'},
            {from: 'Tegra', to: 'ImmortalGraph'},
            {from: 'Tegra', to: 'Wonderland'},
            {from: 'ThunderGP', to: 'Chaos'},
            {from: 'ThunderGP', to: 'ForeGraph'},
            {from: 'TigerGraph', to: 'Giraph'},
            {from: 'TigerGraph', to: 'JanusGraph'},
            {from: 'TigerGraph', to: 'PowerGraph'},
            {from: 'Tigr', to: 'Giraph'},
            {from: 'Tigr', to: 'GraphReduce'},
            {from: 'Tornado', to: 'ASPIRE'},
            {from: 'Tornado', to: 'Naiad'},
            {from: 'Tornado', to: 'Trinity'},
            {from: 'Trinity', to: 'Giraph'},
            {from: 'Trinity', to: 'GraphChi'},
            {from: 'Tripoline', to: 'Chaos'},
            {from: 'Tripoline', to: 'FENNEL'},
            {from: 'Tripoline', to: 'GRAPE'},
            {from: 'Tripoline', to: 'Subway'},
            {from: 'Tripoline', to: 'Tigr'},
            {from: 'TuGraph', to: 'JanusGraph'},
            {from: 'TuGraph', to: 'Neo4j'},
            {from: 'TurboGraph', to: 'Trinity'},
            {from: 'VENUS', to: 'GasCL'},
            {from: 'VENUS', to: 'MOCgraph'},
            {from: 'VGL', to: 'CuSha'},
            {from: 'VGL', to: 'Ligra'},
            {from: 'Version Traveler', to: 'LFGraph'},
            {from: 'Version Traveler', to: 'LLAMA'},
            {from: 'Version Traveler', to: 'MOCgraph'},
            {from: 'Version Traveler', to: 'Ringo'},
            {from: 'Version Traveler', to: 'X-Stream'},
            {from: 'VeilGraph', to: 'Tornado'},
            {from: 'Weaver', to: 'Blogel'},
            {from: 'Weaver', to: 'GraphX'},
            {from: 'Weaver', to: 'GridGraph'},
            {from: 'Weaver', to: 'MOCgraph'},
            {from: 'Weaver', to: 'Pregelix'},
            {from: 'WolfGraph', to: 'Frog'},
            {from: 'WolfGraph', to: 'Graphie'},
            {from: 'WolfGraph', to: 'Tigr'},
            {from: 'WolfGraph', to: 'Wonderland'},
            {from: 'Wonderland', to: 'G-Store'},
            {from: 'Wonderland', to: 'Gemini'},
            {from: 'Wonderland', to: 'KickStarter'},
            {from: 'X-Stream', to: 'GraphChi'},
            {from: 'XPGraph', to: 'FENNEL'},
            {from: 'XPGraph', to: 'GraphIn'},
            {from: 'XPGraph', to: 'GraphOne'},
            {from: 'XPGraph', to: 'Graphene'},
            {from: 'XPGraph', to: 'LiveGraph'},
            {from: 'XPGraph', to: 'Lumos'},
            {from: 'XPGraph', to: 'faimGraph'},
            {from: 'Zorro', to: 'LFGraph'},
            {from: 'Zorro', to: 'LLAMA'},
            {from: 'Zorro', to: 'X-Stream'},
            {from: 'faimGraph', to: 'GasCL'},
            {from: 'iGraph', to: 'Blogel'},
            {from: 'iGraph', to: 'X-Stream'},
            {from: 'iMapReduce', to: 'HaLoop'},
            {from: 'iMapReduce', to: 'PrIter', _bidirectional: true},
            {from: 'iPregel', to: 'GraphD'},
            {from: 'iTurboGraph', to: 'GraphD'},
            {from: 'iTurboGraph', to: 'GraphOne'},
            {from: 'xDGP', to: 'Mizan'},
        ]);

        // create network
        var container = document.getElementById('network');
        var data = {
            nodes: nodes,
            edges: edges
        };
        nodes.forEach(node => {
            node.label = node.id;
            if (node._type === 'db') {
                node.color = 'white';
            }
        })
        edges.forEach(edge => {
            if (edge._bidirectional) {
                edge.color = 'red';
                edge.arrows = {to: {enabled: true, scaleFactor: 1}, from: {enabled: true, scaleFactor: 1}};
            }
        })
        var options = {
            layout: {
                hierarchical: {
                    enabled: true,
                    levelSeparation: 150,
                    nodeSpacing: 100,
                    treeSpacing: 200,
                    direction: 'RL',
                    sortMethod: 'directed',
                }
            },
            physics: true,
            nodes: {
                shape: 'box',
            },
            edges: {
                color: {
                    color: 'gray',
                    highlight: 'orange',
                    hover: 'orange',
                    inherit: true,
                    opacity: 1.0,
                },
                arrows: 'to',
                smooth: false
            },
        };

        // initialize network
        var network = new vis.Network(container, data, options);

        var selectedNodeId = null

        function activateDownstream(network, nodeId, direction) {
            activatedNodeIds = new Set();
            activatedEdgeIds = new Set();

            function recurse(nodeId) {
                if (!activatedNodeIds.has(nodeId)) {
                    activatedNodeIds.add(nodeId);
                    const edgeIds = network.getConnectedEdges(nodeId);
                    if (direction === 'from') {
                        const outgoingEdgeIds = edgeIds.filter(edgeId => {
                            const edgeData = network.body.data.edges.get(edgeId);
                            if (edgeData.from === nodeId || edgeData._bidirectional) {
                                return edgeId
                            }
                        });
                        activatedEdgeIds = new Set([...activatedEdgeIds, ...outgoingEdgeIds]);
                        outgoingEdgeIds.forEach(edgeId => {
                            const edgeData = network.body.data.edges.get(edgeId);
                            if (edgeData._bidirectional) {
                                recurse(edgeData.from)
                                recurse(edgeData.to)
                            } else {
                                recurse(edgeData.to);
                            }
                        });
                    } else if (direction === 'to') {
                        const ingoingEdgeIds = edgeIds.filter(edgeId => {
                            const edgeData = network.body.data.edges.get(edgeId);
                            if (edgeData.to === nodeId || edgeData._bidirectional) {
                                return edgeId
                            }
                        });
                        activatedEdgeIds = new Set([...activatedEdgeIds, ...ingoingEdgeIds]);
                        ingoingEdgeIds.forEach(edgeId => {
                            const edgeData = network.body.data.edges.get(edgeId);
                            if (edgeData._bidirectional) {
                                recurse(edgeData.from)
                                recurse(edgeData.to)
                            } else {
                                recurse(edgeData.from);
                            }
                        });
                    }

                }
            }

            recurse(nodeId);
            console.log(activatedNodeIds)
            network.selectNodes([...activatedNodeIds], true);
            network.selectEdges([...activatedEdgeIds], true);
        }

        function getNodeLevels(startNode, direction) {
            let stack = [startNode];
            let visited = new Set();
            let levelMap = {};
            levelMap[startNode] = 0;

            while (stack.length > 0) {
                let nodeId = stack.pop();
                if (!visited.has(nodeId)) {
                    visited.add(nodeId);
                    let parentLevel = levelMap[nodeId];
                    let connectedEdges = network.getConnectedEdges(nodeId);
                    for (const edgeId of connectedEdges) {
                        let edge = edges.get(edgeId);
                        if (direction == 'from') {
                            if (edge.from === nodeId && !visited.has(edge.to)) {
                                let newLevel = parentLevel + 1;
                                if (levelMap[edge.to] === undefined || newLevel < levelMap[edge.to]) {
                                    levelMap[edge.to] = newLevel;
                                    stack.push(edge.to);
                                }
                            } else if (edge._bidirectional && !visited.has(edge.from)) {
                                let newLevel = parentLevel + 1;
                                if (levelMap[edge.from] === undefined || newLevel < levelMap[edge.from]) {
                                    levelMap[edge.from] = newLevel;
                                    stack.push(edge.from);
                                }
                            }
                        } else if (direction == 'to') {
                            if (edge.to === nodeId && !visited.has(edge.from)) {
                                let newLevel = parentLevel + 1;
                                if (levelMap[edge.from] === undefined || newLevel < levelMap[edge.from]) {
                                    levelMap[edge.from] = newLevel;
                                    stack.push(edge.from);
                                }
                            } else if (edge._bidirectional && !visited.has(edge.to)) {
                                let newLevel = parentLevel + 1;
                                if (levelMap[edge.to] === undefined || newLevel < levelMap[edge.to]) {
                                    levelMap[edge.to] = newLevel;
                                    stack.push(edge.to);
                                }
                            }
                        }
                    }
                }
            }

            return levelMap;
        }


        function search(selectedNodeId, nodeIds, direction) {
            if (selectedNodeId && nodeIds.length) {
                var levelMap = getNodeLevels(selectedNodeId, direction);
                nodes.update(
                    {id: selectedNodeId, color: 'red', font: {color: 'white', size: 20, bold: 700}}
                );
                let connectedEdges = network.getConnectedEdges(selectedNodeId);
                nodeIds.forEach(nodeId => {
                    activateDownstream(network, nodeId, direction);
                });
                for (const edgeId of connectedEdges) {
                    let edge = edges.get(edgeId);
                    if (direction === 'to' && edge.to === selectedNodeId) {
                        if (!edge._bidirectional) {
                            edges.update({id: edge.id, color: 'green'});
                        }
                    }
                    if (direction === 'from' && edge.from === selectedNodeId) {
                        if (!edge._bidirectional) {
                            edges.update({id: edge.id, color: 'green'});
                        }
                    }
                }
                for (const nodeId in levelMap) {
                    if (levelMap[nodeId] === 1) {
                        nodes.update(
                            {id: nodeId, color: 'green', font: {color: 'white', size: 20, bold: 700}}
                        );
                    } else if (levelMap[nodeId] > 1) {
                        nodes.update(
                            {id: nodeId, color: 'orange', font: {color: 'white', size: 20, bold: 700}}
                        );
                    }
                }

            }
        }

        function getNeighbours() {
            let connectedEdges = network.getConnectedEdges(selectedNodeId);
            let activatedEdgeIds = new Set()
            nodes.update(
                {id: selectedNodeId, color: 'red', font: {color: 'white', size: 20, bold: 700}}
            );
            for (const edgeId of connectedEdges) {
                activatedEdgeIds.add(edgeId)
                let edge = edges.get(edgeId)
                edge.to === selectedNodeId && nodes.update(
                    {id: edge.from, color: 'green', font: {color: 'white', size: 20, bold: 700}}
                );
                edge.from === selectedNodeId && nodes.update(
                    {id: edge.to, color: 'green', font: {color: 'white', size: 20, bold: 700}}
                );
            }
            network.selectEdges([...activatedEdgeIds], true);
        }

        function deselectAllElements() {
            network.unselectAll()
            const nodeDetail = document.getElementById('node-detail');
            if (event && event.target !== nodeDetail && !nodeDetail.contains(event.target)) {
                nodeDetail.style.display = 'none';
            }
            if (event && event.target !== contextMenu && !contextMenu.contains(event.target)) {
                contextMenu.style.display = 'none';
            }
            nodes.forEach(node => {
                if (node._type && node._type === 'db') {
                    nodes.update({id: node.id, color: 'white', font: null, size: 20});
                } else {
                    nodes.update({id: node.id, color: null, font: null, size: 20});
                }
            });
            edges.forEach(edge => {
                edge._bidirectional ? edge.color = 'red' : edge.color = null
                edges.update({...edge});
            });
        }

        function updateDetailContent(nodeId) {
            const nodeDetail = document.getElementById('node-detail');

            while (nodeDetail.firstChild) {
                nodeDetail.removeChild(nodeDetail.firstChild);
            }
            let target = null
            nodes.forEach(node => {
                if (node.id === nodeId) {
                    target = node
                }
            })
            if (target) {
                if (target._paper) {
                    nodeDetail.style.display = 'block';
                    const h3 = document.createElement('h3');
                    const link = document.createElement('a');
                    link.href = `${baseUrl}${target.id}.pdf`;
                    link.textContent = target._paper
                    link.target = '_blank'
                    if (!target._paper.startsWith(target.id)) {
                        const title = document.createElement('b');
                        title.innerText = target.id + ": ";
                        h3.appendChild(title);
                    }
                    h3.appendChild(link);
                    nodeDetail.appendChild(h3);
                }
                if (target._website) {
                    nodeDetail.style.display = 'block';
                    const div = document.createElement('div');
                    const title = document.createElement('b');
                    const link = document.createElement('a');
                    title.innerText = 'Website: ';
                    link.href = target._website;
                    link.textContent = target._website
                    link.target = '_blank'
                    div.appendChild(title);
                    div.appendChild(link);
                    nodeDetail.appendChild(div);
                }
            }
        }

        network.on("selectNode", function (params) {
            isNodeSelected = true;
            const nodeIds = params.nodes;
            deselectAllElements();
            search(params.nodes[0], nodeIds, direction);
            updateDetailContent(params.nodes[0]);
            setTimeout(() => isNodeSelected = false, 100);
        });
        network.on('deselectNode', function () {
            deselectAllElements()
        });
        network.on('click', function (params) {
            if (isNodeSelected) {
                return;
            }
            if (params.nodes.length === 0 && params.edges.length === 0) {
                deselectAllElements();
            }
        });
        input.addEventListener('keyup', function (event) {
            if (event.keyCode === 13) {
                event.preventDefault();
                document.getElementById('searchButton').click();
            }
        });
        document.getElementById('searchButton').addEventListener('click', function () {
            deselectAllElements()
            var searchValue = document.getElementById('searchInput').value;
            if (!searchValue) {
                return
            }
            let target = null
            nodes.forEach((node) => {
                if (node.id.toUpperCase() === searchValue.toUpperCase()) {
                    target = node
                }
            })
            if (target) {
                let id = target.id
                search(id, [id], direction)
                updateDetailContent(id);
            } else {
                alert(`Invalid Graph System: ${searchValue}`)
            }
        });
        network.on("oncontext", function (params) {
            params.event.preventDefault();
            deselectAllElements()
            const nodeIds = network.getNodeAt(params.pointer.DOM);
            if (nodeIds) {
                selectedNodeId = nodeIds;
                contextMenu.style.display = 'block';
                contextMenu.style.left = params.pointer.DOM.x + 'px';
                contextMenu.style.top = params.pointer.DOM.y + 'px';
                updateDetailContent(selectedNodeId);
            } else {
                contextMenu.style.display = 'none';
            }
        });
        document.getElementById('context-menu').addEventListener('click', function (event) {
            const target = event.target;
            switch (target.id) {
                case 'reference-network':
                    search(selectedNodeId, [selectedNodeId], 'from');
                    break;
                case 'citation-network':
                    search(selectedNodeId, [selectedNodeId], 'to');
                    break;
                case 'direct-neighbours':
                    getNeighbours(selectedNodeId);
                    break;
            }
            contextMenu.style.display = 'none';
        });
    </script>
</body>

</html>