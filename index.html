<!DOCTYPE html>
<html>
  <head>
    <title>Awesome-Graphs</title>
    <link rel="stylesheet" type="text/css" href="https://at.alicdn.com/t/a/font_470089_8hnbbf8n4u8.css" />
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous" />
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        position: absolute;
        width: 100%;
        height: 100%;
      }

      #network {
        width: 100%;
        height: 100%;
      }

      .search-bar {
        position: absolute;
        top: 24px;
        left: 12px;
        z-index: 2;
        width: 320px;
        font-size: 14px;
        box-shadow: 0px 0px 8px rgba(0, 0, 0, 0.1);
        border-radius: 8px;
        background-color: #fff;
      }

      #searchInput,
      #searchButton {
        font-size: 14px;
      }

      #search-list {
        position: absolute;
        top: 72px;
        left: 12px;
        z-index: 999;
        width: 320px;
        background-color: #fff;
        display: none;
        font-size: 14px;
        text-align: center;
        max-height: 480px;
        overflow-y: scroll;
      }

      .form-control:focus {
        border-color: var(--bs-btn-border-color);
        box-shadow: none;
      }

      .alert-message {
        font-size: 14px;
        width: 320px;
        height: fit-content;
        top: 72px;
        left: 12px;
        line-height: 24px;
        padding: 6px 0px 6px 12px;
        position: absolute;
        z-index: 1;
      }

      .alert-dismissible .btn-close {
        padding: 14px;
        font-size: 10px;
      }

      .btn-close:focus {
        box-shadow: none;
      }

      #node-detail {
        left: 50%;
        width: max-content;
        top: 20px;
        transform: translateX(-50%);
        position: absolute;
        border: 0;
        border-radius: 5px;
        background-color: transparent;
        padding: 10px;
        z-index: 1000;
        text-align: center;
      }

      .g6-toolbar {
        background: #fff;
        border-radius: 8px !important;
        bottom: 50% !important;
        flex-direction: column !important;
        gap: 4px;
        left: 12px !important;
        opacity: 1 !important;
        padding: 4px !important;
      }

      .g6-toolbar-item {
        display: flex !important;
      }
    </style>
  </head>

  <body>
    <div class="input-group mb-3 search-bar">
      <input type="text" id="searchInput" class="form-control" placeholder="Graph System Name" aria-describedby="searchButton" />
      <button id="searchButton" class="btn btn-outline-secondary" type="button">Search</button>
    </div>
    <div id="search-list"></div>
    <div id="live-alert"></div>
    <div id="node-detail"></div>
    <div id="network"></div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/fuzzy@0.1.3/lib/fuzzy.js"></script>
    <script src="https://unpkg.com/@antv/g6@5/dist/g6.min.js"></script>

    <script type="module">
      const BASE_URL = 'https://github.com/TuGraph-family/Awesome-Graphs/blob/master/papers/';
      const BG_COLOR = '#FFF';
      const PAPER_NODE_COLOR = '#5F95FF';
      const DB_NODE_COLOR = '#61DDAA';
      const UNI_EDGE_COLOR = '#CCC';
      const BI_EDGE_COLOR = '#D94801';
      // Assign color to nodes on the reference link: root, first degree, and others
      const PALETTE = ['#5F95FF', '#61DDAA', '#F08F56'];

      // create nodes
      const nodes = [
        { id: 'A1', _paper: 'A1: A Distributed In-Memory Graph Database' },
        { id: 'ASPIRE', _paper: 'ASPIRE: Exploiting Asynchronous Parallelism in Iterative Algorithms using a Relaxed Consistency based DSM' },
        { id: 'AeonG', _paper: 'AeonG: An Efficient Built-in Temporal Support in Graph Databases (Extended Version)' },
        { id: 'AsynGraph', _paper: 'AsynGraph: Maximizing Data Parallelism for Efficient Iterative Graph Processing on GPUs' },
        { id: 'Auxo', _paper: 'Auxo: A Temporal Graph Management System' },
        { id: 'BG3', _paper: 'BG3: A Cost Effective and I/O Efficient Graph Database in ByteDance' },
        { id: 'Blaze', _paper: 'Blaze: Fast Graph Processing on Fast SSDs' },
        { id: 'BlitzG', _paper: 'BlitzG: Exploiting high-bandwidth networks for fast graph processing' },
        { id: 'Blogel', _paper: 'Blogel: A Block-Centric Framework for Distributed Computation on Real-World Graphs' },
        { id: 'ByteGraph', _paper: 'ByteGraph: A High-Performance Distributed Graph Database in ByteDance' },
        { id: 'CGgraph', _paper: 'CGgraph: An Ultra-fast Graph Processing System on Modern Commodity CPU-GPU Co-processor' },
        { id: 'CGraph', _paper: 'CGraph: A correlations-aware approach for efficient concurrent iterative graph processing' },
        { id: 'CLIP', _paper: 'CLIP: A Disk I/O Focused Parallel Out-of-core Graph Processing System' },
        { id: 'CSMqGraph', _paper: 'CSMqGraph: Coarse-Grained and Multi-external-storage Multi-queue I/O Management for Graph Computing' },
        { id: 'Chaos', _paper: 'Chaos: Scale-out Graph Processing from Secondary Storage' },
        { id: 'Chronograph', _paper: 'Chronograph: A Distributed Processing Platform for Online and Batch Computations on Event-sourced Graphs' },
        { id: 'Chronos', _paper: 'Chronos: A Graph Engine for Temporal Graph Analysis' },
        { id: 'CoRAL', _paper: 'CoRAL: Confined Recovery in Distributed Asynchronous Graph Processing' },
        { id: 'CommonGraph', _paper: 'CommonGraph: Graph Analytics on Evolving Data' },
        { id: 'CuSha', _paper: 'CuSha: Vertex-Centric Graph Processing on GPUs' },
        { id: 'Cymbalo', _paper: 'Cymbalo: An Efficient Graph Processing Framework for Machine Learning' },
        { id: 'D2Graph', _paper: 'D2Graph: An Efficient and Unified Out-of-Core Graph Computing Model' },
        { id: 'DD-Graph', _paper: 'DD-Graph: A Highly Cost-Effective Distributed Disk-based Graph-Processing Framework' },
        { id: 'DFOGraph', _paper: 'DFOGraph: An I/O- and Communication-Efficient System for Distributed Fully-out-of-Core Graph Processing' },
        { id: 'DZiG', _paper: 'DZiG: Sparsity-Aware Incremental Processing of Streaming Graphs' },
        { id: 'DepGraph', _paper: 'DepGraph: A Dependency-Driven Accelerator for Efficient Iterative Graph Processing' },
        { id: 'DiGraph', _paper: 'DiGraph: An Efficient Path-based Iterative Directed Graph Processing System on Multiple GPUs' },
        { id: 'Differential dataflow', _paper: 'Differential dataflow' },
        { id: 'Distributed GraphLab', _paper: 'Distributed GraphLab: A Framework for Machine Learning and Data Mining in the Cloud' },
        { id: 'DiterGraph', _paper: 'DiterGraph: Toward I/O-Efficient Incremental Computation over Large Graphs with Billion Edges' },
        { id: 'DynamoGraph', _paper: 'DynamoGraph: A Distributed System for Large-scale, Temporal Graph Processing, its Implementation and First Observations' },
        { id: 'EGraph', _paper: 'EGraph: Efficient concurrent GPU-based dynamic graph processing' },
        { id: 'EPGraph', _paper: 'EPGraph: An Efficient Graph Computing Model in Persistent Memory System' },
        { id: 'EmptyHeaded', _paper: 'EmptyHeaded: A Relational Engine for Graph Processing' },
        { id: 'FBSGraph', _paper: 'FBSGraph: Accelerating Asynchronous Graph Processing via Forward and Backward Sweeping' },
        { id: 'FENNEL', _paper: 'FENNEL: Streaming Graph Partitioning for Massive Scale Graphs' },
        { id: 'FOG', _paper: 'FOG: A Fast Out-of-Core Graph Processing Framework' },
        { id: 'Fargraph+', _paper: 'Fargraph+: Excavating the parallelism of graph processing workload on RDMA-based far memory system' },
        { id: 'FlashGraph', _paper: 'FlashGraph: Processing Billion-Node Graphs on an Array of Commodity SSDs' },
        { id: 'ForeGraph', _paper: 'ForeGraph: Exploring Large-scale Graph Processing on Multi-FPGA Architecture' },
        { id: 'Frog', _paper: 'Frog: Asynchronous graph processing on GPU with hybrid coloring model' },
        { id: 'G-Store', _paper: 'G-Store: High-Performance Graph Store for Trillion-Edge Processing' },
        { id: 'G-Tran', _paper: 'G-Tran: A High Performance Distributed Graph Database with a Decentralized Architecture' },
        { id: 'GBASE', _paper: 'GBASE: A Scalable and General Graph Management System' },
        { id: 'GFlink', _paper: 'GFlink: An In-Memory Computing Architecture on Heterogeneous CPU-GPU Clusters for Big Data' },
        { id: 'GGraph', _paper: 'GGraph: An Efficient Structure-Aware Approach for Iterative Graph Processing' },
        { id: 'GPOP', _paper: 'GPOP: A scalable cache- and memory-efficient framework for Graph Processing Over Partitions' },
        { id: 'GPS', _paper: 'GPS: A Graph Processing System' },
        { id: 'GRAM', _paper: 'GRAM: Scaling Graph Computation to the Trillions' },
        { id: 'GRAPE', _paper: 'GRAPE: Parallelizing Sequential Graph Computations' },
        { id: 'GRE', _paper: 'GRE: A Graph Runtime Engine for Large-Scale Distributed Graph-Parallel Applications' },
        { id: 'GStream', _paper: 'GStream: A Graph Streaming Processing Method for Large-scale Graphs on GPUs' },
        { id: 'Garaph', _paper: 'Garaph: Efficient GPU-accelerated Graph Processing on a Single Machine with Balanced Replication' },
        { id: 'GasCL', _paper: 'GasCL: A Vertex-Centric Graph Model for GPUs' },
        { id: 'GeaFlow', _paper: 'GeaFlow: A Graph Extended and Accelerated Dataflow System' },
        { id: 'Gemini', _paper: 'Gemini: A Computation-Centric Distributed Graph Processing System' },
        { id: 'Giraph Unchained', _paper: 'Giraph Unchained: Barrierless Asynchronous Parallel Execution in Pregel-like Graph Processing Systems' },
        { id: 'Giraph', _website: 'http://giraph.apache.org', _type: 'db' },
        { id: 'GoFFish', _paper: 'GoFFish: A Sub-graph Centric Framework for Large-Scale Graph Analytics' },
        { id: 'GraPU', _paper: 'GraPU: Accelerate Streaming Graph Analysis through Preprocessing Buffered Updates' },
        { id: 'GraVF', _paper: 'GraVF: A Vertex-Centric Distributed Graph Processing Framework on FPGAs' },
        { id: 'Gradoop', _paper: 'Analyzing Temporal Graphs with Gradoop' },
        { id: 'GrapH', _paper: 'GrapH: Traffic-Aware Graph Processing' },
        { id: 'Graph Database', _type: 'db' },
        { id: 'Graph3S', _paper: 'Graph3S: A Simple, Speedy and Scalable Distributed Graph Processing System' },
        { id: 'GraphA', _paper: 'GraphA: An efficient ReRAM-based architecture to accelerate large scale graph processing' },
        { id: 'GraphABCD', _paper: 'GraphABCD: Scaling Out Graph Analytics with Asynchronous Block Coordinate Descent' },
        { id: 'GraphBolt', _paper: 'GraphBolt: Dependency-Driven Synchronous Processing of Streaming Graphs' },
        { id: 'GraphBuilder', _paper: 'GraphBuilder: Scalable Graph ETL Framework' },
        { id: 'GraphCP', _paper: 'GraphCP: An I/O-Efficient Concurrent Graph Processing Framework' },
        { id: 'GraphCage', _paper: 'GraphCage: Cache Aware Graph Processing on GPUs' },
        { id: 'GraphChi', _paper: 'GraphChi: Large-Scale Graph Computation on Just a PC' },
        { id: 'GraphD', _paper: 'GraphD: Distributed Vertex-Centric Graph Processing Beyond the Memory Limit' },
        { id: 'GraphDuo', _paper: 'GraphDuo: A Dual-Model Graph Processing Framework' },
        { id: 'GraphFly', _paper: 'GraphFly: Efficient Asynchronous Streaming Graphs Processing via Dependency-Flow' },
        { id: 'GraphGen', _paper: 'GraphGen: An FPGA Framework for Vertex-Centric Graph Computation' },
        { id: 'GraphGrind', _paper: 'GraphGrind: addressing load imbalance of graph partitioning' },
        { id: 'GraphH(1)', label: 'GraphH(1)', _paper: 'GraphH(1): High Performance Big Graph Analytics in Small Clusters' },
        { id: 'GraphH(2)', label: 'GraphH(2)', _paper: 'GraphH(2): A Processing-in-Memory Architecture for Large-scale Graph Processing' },
        { id: 'GraphIA', _paper: 'GraphIA: An In-situ Accelerator for Large-scale Graph Processing' },
        { id: 'GraphIn', _paper: 'GraphIn: An Online High Performance Incremental Graph Processing Framework' },
        { id: 'GraphLab', _paper: 'GraphLab: A New Framework For Parallel Machine Learning' },
        { id: 'GraphM', _paper: 'GraphM: An Efficient Storage System for High Throughput of Concurrent Graph Processing' },
        { id: 'GraphMP(1)', label: 'GraphMP(1)', _paper: 'GraphMP(1): An Efficient Semi-External-Memory Big Graph Processing System on a Single Machine' },
        { id: 'GraphMP(2)', label: 'GraphMP(2)', _paper: 'GraphMP(2): I/O-Efficient Big Graph Analytics on a Single Commodity Machine' },
        { id: 'GraphMap', _paper: 'GraphMap: scalable iterative graph processing using NoSQL' },
        { id: 'GraphMat', _paper: 'GraphMat: High performance graph analytics made productive' },
        { id: 'GraphOne', _paper: 'GraphOne: A Data Store for Real-time Analytics on Evolving Graphs' },
        { id: 'GraphP', _paper: 'GraphP: Reducing Communication for PIM-based Graph Processing with Efficient Data Partition' },
        { id: 'GraphPEG', _paper: 'GraphPEG: Accelerating Graph Processing on GPUs' },
        { id: 'GraphPIM', _paper: 'GraphPIM: Enabling Instruction-Level PIM Offloading in Graph Computing Frameworks' },
        { id: 'GraphPhi', _paper: 'GraphPhi: Efficient Parallel Graph Processing on Emerging Throughput-oriented Architectures' },
        { id: 'GraphPulse', _paper: 'GraphPulse: An Event-Driven Hardware Accelerator for Asynchronous Graph Processing' },
        { id: 'GraphQ', _paper: 'GraphQ: Graph Query Processing with Abstraction Refinement' },
        { id: 'GraphR', _paper: 'GraphR: Accelerating Graph Processing Using ReRAM' },
        { id: 'GraphReduce', _paper: 'GraphReduce: Processing Large-Scale Graphs on Accelerator-Based Systems' },
        { id: 'GraphSD', _paper: 'GraphSD: A State and Dependency aware Out-of-Core Graph Processing System' },
        { id: 'GraphScSh', _paper: 'GraphScSh: Efficient I/O Scheduling and Graph Sharing for Concurrent Graph Processing' },
        { id: 'GraphScope', _paper: 'GraphScope: A Unified Engine For Big Graph Processing' },
        { id: 'GraphTides', _paper: 'GraphTides: A Framework for Evaluating Stream-based Graph Processing Platforms' },
        { id: 'GraphTinker', _paper: 'GraphTinker: A High Performance Data Structure for Dynamic Graph Processing' },
        { id: 'GraphTune', _paper: 'GraphTune: An Efficient Dependency-Aware Substrate to Alleviate Irregularity in Concurrent Graph Processing' },
        { id: 'GraphTwist', _paper: 'GraphTwist: Fast Iterative Graph Computation with Two-tier Optimizations' },
        { id: 'GraphX', _paper: 'GraphX: A Resilient Distributed Graph System on Spark' },
        { id: 'GraphZ', _paper: 'GraphZ: Improving the Performance of Large-Scale Graph Analytics on Small-Scale Machines' },
        { id: 'Graphene', _paper: 'Graphene: Fine-Grained IO Management for Graph Computing' },
        { id: 'Graphflow', _paper: 'Graphflow: An Active Graph Database' },
        { id: 'Graphie', _paper: 'Graphie: Large-Scale Asynchronous Graph Traversals on Just a GPU' },
        { id: 'Graspan', _paper: 'Graspan: A Single-machine Disk-based Graph System for Interprocedural Static Analyses of Large-scale Systems Code' },
        { id: 'Grasper', _paper: 'Grasper: A High Performance Distributed System for OLAP on Property Graphs' },
        { id: 'GridGraph', _paper: 'GridGraph: Large-Scale Graph Processing on a Single Machine Using 2-Level Hierarchical Partitioning' },
        { id: 'Groute', _paper: 'Groute: Asynchronous Multi-GPU Programming Model with Applications to Large-scale Graph Processing' },
        { id: 'HGraph', _paper: 'HGraph: I/O-efficient Distributed and Iterative Graph Computing by Hybrid Pushing/Pulling' },
        { id: 'HPGraph', _paper: 'HPGraph: A High Parallel Graph Processing System Based on Flash Array' },
        { id: 'HUS-Graph', _paper: 'HUS-Graph: I/O-Efficient Out-of-Core Graph Processing with Hybrid Update Strategy' },
        { id: 'HaLoop', _paper: 'HaLoop: Efficient Iterative Data Processing on Large Clusters' },
        { id: 'HipG', _paper: 'HipG: Parallel Processing of Large-Scale Graphs' },
        { id: 'HitGraph', _paper: 'HitGraph: High-throughput Graph Processing Framework on FPGA' },
        { id: 'HotGraph', _paper: 'HotGraph: Efficient Asynchronous Processing for Real-World Graphs' },
        { id: 'HyTGraph', _paper: 'HyTGraph: GPU-Accelerated Graph Processing with Hybrid Transfer Management' },
        { id: 'HyVE', _paper: 'HyVE: Hybrid Vertex-Edge Memory Hierarchy for Energy-Efficient Graph Processing' },
        { id: 'HybridGraph', _paper: 'HybridGraph: Hybrid Pulling:Pushing for I:O-Efficient Distributed and Iterative Graph Computing' },
        { id: 'ImmortalGraph', _paper: 'ImmortalGraph: A System for Storage and Analysis of Temporal Graphs' },
        { id: 'JanusGraph', _website: 'http://janusgraph.org', _type: 'db' },
        { id: 'JetStream', _paper: 'JetStream: Graph Analytics on Streaming Data with Event-Driven Hardware Accelerator' },
        { id: 'KickStarter', _paper: 'KickStarter: Fast and Accurate Computations on Streaming Graphs via Trimmed Approximations' },
        { id: 'Kineograph', _paper: 'Kineograph: Taking the Pulse of a Fast-Changing and Connected World' },
        { id: 'L-PowerGraph', _paper: 'L-PowerGraph: a lightweight distributed graph-parallel communication mechanism' },
        { id: 'LCC-Graph', _paper: 'LCC-Graph: A High-Performance Graph-Processing Framework with Low Communication Costs' },
        { id: 'LFGraph', _paper: 'LFGraph: Simple and Fast Distributed Graph Analytics' },
        { id: 'LLAMA', _paper: 'LLAMA: Efficient Graph Analytics Using Large Multiversioned Arrays.' },
        { id: 'LOSC', _paper: 'LOSC: Efficient Out-of-Core Graph Processing with Locality-optimized Subgraph Construction' },
        { id: 'LSGraph', _paper: 'LSGraph: A Locality-centric High-performance Streaming Graph Engine' },
        { id: 'LargeGraph', _paper: 'LargeGraph: An Efficient Dependency-Aware GPU-Accelerated Large-Scale Graph Processing' },
        { id: 'LazyGraph', _paper: 'LazyGraph: Lazy Data Coherency for Replicas in Distributed Graph-Parallel Computation' },
        { id: 'LightGraph', _paper: 'LightGraph: Lighten Communication in Distributed Graph-Parallel Processing' },
        { id: 'Ligra', _paper: 'Ligra: A Lightweight Graph Processing Framework for Shared Memory' },
        { id: 'LiveGraph', _paper: 'LiveGraph: A Transactional Graph Storage System with Purely Sequential Adjacency List Scans' },
        { id: 'Lumos', _paper: 'Lumos: Dependency-Driven Disk-based Graph Processing' },
        { id: 'MMap', _paper: 'MMap: Fast Billion-Scale Graph Computation on a PC via Memory Mapping' },
        { id: 'MOCgraph', _paper: 'MOCgraph: Scalable Distributed Graph Processing Using Message Online Computing' },
        { id: 'MOSAIC', _paper: 'MOSAIC: Processing a Trillion-Edge Graph on a Single Machine' },
        { id: 'Maiter', _paper: 'Maiter: An Asynchronous Graph Processing Framework for Delta-based Accumulative Iterative Computation' },
        { id: 'MapGraph', _paper: 'MapGraph: A High Level API for Fast Development of High Performance Graph Analytics on GPUs' },
        { id: 'Medusa', _paper: 'Medusa: Simplified Graph Processing on GPUs' },
        { id: 'Mizan', _paper: 'Mizan: A System for Dynamic Load Balancing in Large-scale Graph Processing' },
        { id: 'MultiLogVC', _paper: 'MultiLogVC: Efficient Out-of-Core Graph Processing Framework for Flash Storage' },
        { id: 'NGraph', _paper: 'NGraph: Parallel Graph Processing in Hybrid Memory Systems' },
        { id: 'NPGraph', _paper: 'NPGraph: An Efficient Graph Computing Model in NUMA-Based Persistent Memory Systems' },
        { id: 'NScale', _paper: 'NScale: Neighborhood-centric Analytics on Large Graphs' },
        { id: 'NXgraph', _paper: 'NXgraph: An Efficient Graph Processing System on a Single Machine* ' },
        { id: 'Naiad', _paper: 'Naiad: A Timely Dataflow System' },
        { id: 'Neo4j', _website: 'https://neo4j.com', _type: 'db' },
        { id: 'PGAbB', _paper: 'PGAbB: A Block-Based Graph Processing Framework for Heterogeneous Platforms' },
        { id: 'PGX.D', label: 'PGX.D', _paper: 'PGX.D: A Fast Distributed Graph Processing Engine' },
        { id: 'PartitionedVC', _paper: 'PartitionedVC: Partitioned External Memory Graph Analytics Framework for SSDs' },
        { id: 'PathGraph', _paper: 'PathGraph: A Path Centric Graph Processing System' },
        { id: 'Pimiento', _paper: 'Pimiento: A Vertex-Centric Graph-Processing Framework on a Single Machine' },
        { id: 'PowerGraph', _paper: 'PowerGraph: Distributed Graph-Parallel Computation on Natural Graphs' },
        { id: 'PowerLyra', _paper: 'PowerLyra: Differentiated Graph Computation and Partitioning on Skewed Graphs' },
        { id: 'PrIter', _paper: 'PrIter: A Distributed Framework for Prioritized Iterative Computations' },
        { id: 'Pregel', _paper: 'Pregel: A System for Large-Scale Graph Processing' },
        { id: 'Pregelix', _paper: 'Pregelix: Big(ger) Graph Analytics on A Dataflow Engine' },
        { id: 'Quegel', _paper: 'Quegel: A General-Purpose Query-Centric Framework for Querying Big Graphs' },
        { id: 'Raphtory', _paper: 'Raphtory: Streaming Analysis Of Distributed Temporal Graphs' },
        { id: 'ReGraph', _paper: 'ReGraph: A Graph Processing Framework that Alternately Shrinks and Repartitions the Graph' },
        { id: 'Ringo', _paper: 'Ringo: Interactive Graph Analytics on Big-Memory Machines' },
        { id: 'RisGraph', _paper: 'RisGraph: A Real-Time Streaming System for Evolving Graphs to Support Sub-millisecond Per-update Analysis at Millions Ops/s' },
        { id: 'SGraph', _paper: 'SGraph: A Distributed Streaming System for Processing Big Graphs' },
        { id: 'STINGER', _paper: 'STINGER: High Performance Data Structure for Streaming Graphs' },
        { id: 'SaGraph', _paper: 'SaGraph: A Similarity-aware Hardware Accelerator for Temporal Graph Processing' },
        { id: 'ScalaGraph', _paper: 'ScalaGraph: A Scalable Accelerator for Massively Parallel Graph Processing' },
        { id: 'ScaleG', _paper: 'ScaleG: A Distributed Disk-based System for Vertex-centric Graph Processing' },
        { id: 'Scaph', _paper: 'Scaph: Scalable GPU-Accelerated Graph Processing with Value-Driven Differential Scheduling' },
        { id: 'Seraph', _paper: 'Seraph: an Efficient, Low-cost System for Concurrent Graph Processing' },
        { id: 'ShenTu', _paper: 'ShenTu: Processing Multi-Trillion Edge Graphs on Millions of Cores in Seconds' },
        { id: 'Subway', _paper: 'Subway: Minimizing Data Transfer during Out-of-GPU-Memory Graph Processing' },
        { id: 'SympleGraph', _paper: 'SympleGraph: Distributed Graph Processing with Precise Loop-Carried Dependency Guarantee' },
        { id: 'TDGraph', _paper: 'TDGraph: A Topology-Driven Accelerator for High-Performance Streaming Graph Processing' },
        { id: 'TIDE', _paper: 'TIDE: Dynamic Interaction Graphs with Probabilistic Edge Decay' },
        { id: 'TeGraph', _paper: 'TeGraph: A Novel General-Purpose Temporal Graph Computing Engine' },
        { id: 'TeGraph+', _paper: 'TeGraph+: Scalable Temporal Graph Processing Enabling Flexible Edge Modifications' },
        { id: 'Tegra', _paper: 'Tegra: Efficient Ad-Hoc Analytics on Evolving Graphs' },
        { id: 'ThunderGP', _paper: 'ThunderGP: HLS-based graph processing framework on FPGAs' },
        { id: 'TigerGraph', _paper: 'TigerGraph: A Native MPP Graph Database', _website: 'https://www.tigergraph.com', _type: 'db' },
        { id: 'Tigr', _paper: 'Tigr: Transforming Irregular Graphs for GPU-Friendly Graph Processing' },
        { id: 'Tornado', _paper: 'Tornado: A System For Real-Time Iterative Analysis Over Evolving Data' },
        { id: 'Trinity', _paper: 'Trinity: A Distributed Graph Engine on a Memory Cloud' },
        { id: 'Tripoline', _paper: 'Tripoline: Generalized Incremental Graph Processing via Graph Triangle Inequality' },
        { id: 'TuGraph', _website: 'https://tugraph.tech', _type: 'db' },
        { id: 'TurboGraph', _paper: 'TurboGraph: A Fast Parallel Graph Engine Handling Billion-scale Graphs in a Single PC' },
        { id: 'VENUS', _paper: 'VENUS: A System for Streamlined Graph Computation on a Single PC' },
        { id: 'VGL', _paper: 'VGL: a high-performance graph processing framework for the NEC SX-Aurora TSUBASA vector architecture' },
        { id: 'VeilGraph', _paper: 'VeilGraph: Approximating Graph Streams' },
        { id: 'Version Traveler', _paper: 'Version Traveler: Fast and Memory-Efficient Version Switching in Graph Processing Systems' },
        { id: 'Weaver', _paper: 'Weaver: A High-Performance, Transactional Graph Database Based on Refinable Timestamps' },
        { id: 'WolfGraph', _paper: 'WolfGraph: the Edge-Centric graph processing on GPU' },
        { id: 'Wonderland', _paper: 'Wonderland: A Novel Abstraction-Based Out-Of-Core Graph Processing System' },
        { id: 'X-Stream', _paper: 'X-Stream: Edge-centric Graph Processing using Streaming Partitions' },
        { id: 'XPGraph', _paper: 'XPGraph: XPline-Friendly Persistent Memory Graph Stores for Large-Scale Evolving Graphs' },
        { id: 'Zorro', _paper: 'Zorro: Zero-Cost Reactive Failure Recovery in Distributed Graph Processing' },
        { id: 'faimGraph', _paper: 'faimGraph: High Performance Management of Fully-Dynamic Graphs under tight Memory Constraints on the GPU' },
        { id: 'iGraph', _paper: 'iGraph: an incremental data processing system for dynamic graph' },
        { id: 'iMapReduce', _paper: 'iMapReduce: A Distributed Computing Framework for Iterative Computation' },
        { id: 'iPregel', _paper: 'iPregel: A Combiner-Based In-Memory Shared Memory Vertex-Centric Framework' },
        { id: 'iTurboGraph', _paper: 'iTurboGraph: Scaling and Automating Incremental Graph Analytics' },
        { id: 'xDGP', _paper: 'xDGP: A Dynamic Graph Processing System with Adaptive Partitioning' },
      ];

      // create edges
      const edges = [
        { from: 'A1', to: 'Trinity' },
        { from: 'ASPIRE', to: 'Ligra' },
        { from: 'AeonG', to: 'Auxo' },
        { from: 'AeonG', to: 'G-Tran' },
        { from: 'AeonG', to: 'Gradoop' },
        { from: 'AeonG', to: 'Graphflow' },
        { from: 'AeonG', to: 'LiveGraph' },
        { from: 'AsynGraph', to: 'DiGraph' },
        { from: 'AsynGraph', to: 'Garaph' },
        { from: 'AsynGraph', to: 'Maiter' },
        { from: 'AsynGraph', to: 'Tigr' },
        { from: 'Auxo', to: 'Chronos' },
        { from: 'BG3', to: 'ByteGraph' },
        { from: 'Blaze', to: 'Lumos' },
        { from: 'BlitzG', to: 'DD-Graph' },
        { from: 'BlitzG', to: 'GRAM' },
        { from: 'BlitzG', to: 'GoFFish' },
        { from: 'BlitzG', to: 'MOCgraph' },
        { from: 'BlitzG', to: 'Seraph' },
        { from: 'Blogel', to: 'Giraph' },
        { from: 'Blogel', to: 'PowerGraph' },
        { from: 'ByteGraph', to: 'G-Tran' },
        { from: 'ByteGraph', to: 'Graphflow' },
        { from: 'ByteGraph', to: 'LiveGraph' },
        { from: 'CGgraph', to: 'GPOP' },
        { from: 'CGgraph', to: 'HyTGraph' },
        { from: 'CGgraph', to: 'LargeGraph' },
        { from: 'CGraph', to: 'GRAM' },
        { from: 'CGraph', to: 'HUS-Graph' },
        { from: 'CGraph', to: 'MOSAIC' },
        { from: 'CGraph', to: 'NXgraph' },
        { from: 'CGraph', to: 'Seraph' },
        { from: 'CGraph', to: 'Version Traveler' },
        { from: 'CSMqGraph', to: 'Graphene' },
        { from: 'CSMqGraph', to: 'HGraph' },
        { from: 'CSMqGraph', to: 'NXgraph' },
        { from: 'Chaos', to: 'GRAM', _bidirectional: true },
        { from: 'Chaos', to: 'GridGraph' },
        { from: 'Chronograph', to: 'ImmortalGraph' },
        { from: 'Chronos', to: 'Ligra' },
        { from: 'Chronos', to: 'Naiad' },
        { from: 'CLIP', to: 'Graphene' },
        { from: 'CoRAL', to: 'ASPIRE' },
        { from: 'CoRAL', to: 'Trinity' },
        { from: 'CommonGraph', to: 'GraphOne' },
        { from: 'CommonGraph', to: 'JetStream' },
        { from: 'CommonGraph', to: 'TDGraph' },
        { from: 'CommonGraph', to: 'Tripoline' },
        { from: 'CuSha', to: 'Medusa' },
        { from: 'Cymbalo', to: 'GraphD' },
        { from: 'Cymbalo', to: 'Wonderland' },
        { from: 'D2Graph', to: 'GraphMP(2)' },
        { from: 'D2Graph', to: 'Graphene' },
        { from: 'D2Graph', to: 'MMap' },
        { from: 'D2Graph', to: 'WolfGraph' },
        { from: 'DD-Graph', to: 'Chaos' },
        { from: 'DFOGraph', to: 'HGraph' },
        { from: 'DFOGraph', to: 'HybridGraph' },
        { from: 'DFOGraph', to: 'Lumos' },
        { from: 'DZiG', to: 'GraphOne' },
        { from: 'DZiG', to: 'ImmortalGraph' },
        { from: 'DZiG', to: 'Lumos' },
        { from: 'DepGraph', to: 'AsynGraph' },
        { from: 'DepGraph', to: 'GGraph' },
        { from: 'DepGraph', to: 'GraphABCD' },
        { from: 'DepGraph', to: 'GraphM' },
        { from: 'DepGraph', to: 'GraphPIM' },
        { from: 'DepGraph', to: 'GraphR' },
        { from: 'DepGraph', to: 'NGraph' },
        { from: 'DiGraph', to: 'FBSGraph' },
        { from: 'DiGraph', to: 'GraphGrind' },
        { from: 'DiGraph', to: 'Graphie' },
        { from: 'DiGraph', to: 'HotGraph' },
        { from: 'DiGraph', to: 'NXgraph' },
        { from: 'DiGraph', to: 'ReGraph' },
        { from: 'DiGraph', to: 'Wonderland' },
        { from: 'Differential dataflow', to: 'Pregel' },
        { from: 'Differential dataflow', to: 'iMapReduce' },
        { from: 'Distributed GraphLab', to: 'PrIter' },
        { from: 'DiterGraph', to: 'HybridGraph' },
        { from: 'DynamoGraph', to: 'ImmortalGraph' },
        { from: 'EGraph', to: 'DZiG' },
        { from: 'EGraph', to: 'DiGraph' },
        { from: 'EGraph', to: 'GraphTinker' },
        { from: 'EPGraph', to: 'D2Graph' },
        { from: 'EPGraph', to: 'DFOGraph' },
        { from: 'EPGraph', to: 'HyVE' },
        { from: 'EmptyHeaded', to: 'GraphX' },
        { from: 'EmptyHeaded', to: 'Ligra' },
        { from: 'FBSGraph', to: 'CoRAL' },
        { from: 'FBSGraph', to: 'PowerLyra' },
        { from: 'FBSGraph', to: 'Pregelix' },
        { from: 'Fargraph+', to: 'GraphCP' },
        { from: 'Fargraph+', to: 'HUS-Graph' },
        { from: 'FENNEL', to: 'PowerGraph' },
        { from: 'FOG', to: 'FlashGraph' },
        { from: 'FOG', to: 'GridGraph' },
        { from: 'FlashGraph', to: 'Maiter' },
        { from: 'FlashGraph', to: 'TurboGraph' },
        { from: 'ForeGraph', to: 'Gemini' },
        { from: 'ForeGraph', to: 'GraVF' },
        { from: 'ForeGraph', to: 'GraphGen' },
        { from: 'ForeGraph', to: 'NXgraph' },
        { from: 'Frog', to: 'CuSha' },
        { from: 'Frog', to: 'Ligra' },
        { from: 'Frog', to: 'X-Stream' },
        { from: 'G-Store', to: 'Chaos' },
        { from: 'G-Tran', to: 'A1' },
        { from: 'G-Tran', to: 'PowerLyra' },
        { from: 'G-Tran', to: 'SGraph' },
        { from: 'G-Tran', to: 'TigerGraph' },
        { from: 'G-Tran', to: 'Weaver' },
        { from: 'GBASE', to: 'Pregel' },
        { from: 'GFlink', to: 'Medusa' },
        { from: 'GGraph', to: 'FBSGraph' },
        { from: 'GGraph', to: 'GrapH' },
        { from: 'GGraph', to: 'GraphA' },
        { from: 'GGraph', to: 'GraphM' },
        { from: 'GGraph', to: 'HGraph' },
        { from: 'GGraph', to: 'HUS-Graph' },
        { from: 'GPOP', to: 'GoFFish' },
        { from: 'GPOP', to: 'GridGraph' },
        { from: 'GPS', to: 'iMapReduce' },
        { from: 'Gradoop', to: 'Raphtory' },
        { from: 'GRAM', to: 'PowerLyra' },
        { from: 'GRAPE', to: 'Blogel' },
        { from: 'GStream', to: 'CuSha' },
        { from: 'GStream', to: 'Trinity' },
        { from: 'GStream', to: 'TurboGraph' },
        { from: 'Garaph', to: 'Chaos' },
        { from: 'Garaph', to: 'CuSha' },
        { from: 'Garaph', to: 'GStream' },
        { from: 'Garaph', to: 'Gemini' },
        { from: 'GasCL', to: 'Medusa' },
        { from: 'GasCL', to: 'X-Stream' },
        { from: 'GeaFlow', to: 'ByteGraph' },
        { from: 'GeaFlow', to: 'RisGraph' },
        { from: 'GeaFlow', to: 'TuGraph' },
        { from: 'GeaFlow', to: 'iGraph' },
        { from: 'Gemini', to: 'GridGraph' },
        { from: 'Gemini', to: 'LazyGraph' },
        { from: 'Giraph Unchained', to: 'Pregelix' },
        { from: 'Giraph', to: 'Graph Database' },
        { from: 'GoFFish', to: 'Trinity' },
        { from: 'GraPU', to: 'Gemini' },
        { from: 'GraPU', to: 'GoFFish' },
        { from: 'GraPU', to: 'KickStarter' },
        { from: 'GraPU', to: 'Tigr' },
        { from: 'GraPU', to: 'Version Traveler' },
        { from: 'GraPU', to: 'Wonderland' },
        { from: 'GraPU', to: 'Zorro' },
        { from: 'GraVF', to: 'GraphGen' },
        { from: 'GrapH', to: 'GridGraph' },
        { from: 'Graph3S', to: 'Graphene' },
        { from: 'Graph3S', to: 'HybridGraph' },
        { from: 'GraphA', to: 'GFlink' },
        { from: 'GraphA', to: 'GraphR' },
        { from: 'GraphABCD', to: 'CLIP' },
        { from: 'GraphABCD', to: 'ForeGraph' },
        { from: 'GraphABCD', to: 'GraphP' },
        { from: 'GraphABCD', to: 'Tigr' },
        { from: 'GraphABCD', to: 'Wonderland' },
        { from: 'GraphBolt', to: 'GraphIn' },
        { from: 'GraphBolt', to: 'KickStarter' },
        { from: 'GraphBuilder', to: 'Trinity' },
        { from: 'GraphCP', to: 'CGraph' },
        { from: 'GraphCP', to: 'GraphM' },
        { from: 'GraphCP', to: 'GraphZ' },
        { from: 'GraphCP', to: 'Seraph' },
        { from: 'GraphCP', to: 'VENUS' },
        { from: 'GraphCage', to: 'GraphMat' },
        { from: 'GraphCage', to: 'GraphPhi' },
        { from: 'GraphChi', to: 'GPS' },
        { from: 'GraphChi', to: 'PowerGraph', _bidirectional: true },
        { from: 'GraphD', to: 'Blogel' },
        { from: 'GraphD', to: 'G-Store' },
        { from: 'GraphD', to: 'Pregelix' },
        { from: 'GraphD', to: 'VENUS' },
        { from: 'GraphDuo', to: 'GrapH' },
        { from: 'GraphDuo', to: 'GraphD' },
        { from: 'GraphDuo', to: 'GraphIn' },
        { from: 'GraphDuo', to: 'GraphP' },
        { from: 'GraphDuo', to: 'Wonderland' },
        { from: 'GraphFly', to: 'LiveGraph' },
        { from: 'GraphFly', to: 'ScalaGraph' },
        { from: 'GraphFly', to: 'Tripoline' },
        { from: 'GraphGen', to: 'GraphChi' },
        { from: 'GraphGrind', to: 'Ligra' },
        { from: 'GraphH(1)', to: 'Chaos' },
        { from: 'GraphH(1)', to: 'MOCgraph' },
        { from: 'GraphH(2)', to: 'Garaph' },
        { from: 'GraphH(2)', to: 'GraphPIM' },
        { from: 'GraphH(2)', to: 'MOCgraph' },
        { from: 'GraphH(2)', to: 'NXgraph' },
        { from: 'GraphIA', to: 'Gemini' },
        { from: 'GraphIA', to: 'GraphH(2)' },
        { from: 'GraphIA', to: 'GraphP' },
        { from: 'GraphIA', to: 'NXgraph' },
        { from: 'GraphIn', to: 'GraphMat' },
        { from: 'GraphIn', to: 'GraphReduce' },
        { from: 'GraphIn', to: 'STINGER' },
        { from: 'GraphLab', to: 'Pregel' },
        { from: 'GraphM', to: 'DiGraph' },
        { from: 'GraphM', to: 'GraphR' },
        { from: 'GraphM', to: 'Lumos' },
        { from: 'GraphMP(1)', to: 'GraphD' },
        { from: 'GraphMP(1)', to: 'GraphH(1)' },
        { from: 'GraphMP(1)', to: 'MOSAIC' },
        { from: 'GraphMP(2)', to: 'GraphMP(1)' },
        { from: 'GraphMap', to: 'DiGraph' },
        { from: 'GraphMap', to: 'GraphD' },
        { from: 'GraphMap', to: 'GraphTwist' },
        { from: 'GraphMap', to: 'Pregelix' },
        { from: 'GraphMat', to: 'GraphX' },
        { from: 'GraphMat', to: 'MapGraph' },
        { from: 'GraphOne', to: 'GBASE' },
        { from: 'GraphOne', to: 'GraPU' },
        { from: 'GraphOne', to: 'GraphBolt' },
        { from: 'GraphOne', to: 'GraphD' },
        { from: 'GraphOne', to: 'Graphene' },
        { from: 'GraphOne', to: 'MOSAIC' },
        { from: 'GraphOne', to: 'TIDE' },
        { from: 'GraphP', to: 'GraphPIM' },
        { from: 'GraphP', to: 'GridGraph' },
        { from: 'GraphPEG', to: 'DiGraph' },
        { from: 'GraphPEG', to: 'GraphCage' },
        { from: 'GraphPEG', to: 'Tigr' },
        { from: 'GraphPIM', to: 'GraphChi' },
        { from: 'GraphPhi', to: 'GraphReduce' },
        { from: 'GraphPhi', to: 'Graphie' },
        { from: 'GraphPulse', to: 'FBSGraph' },
        { from: 'GraphPulse', to: 'GraphPIM' },
        { from: 'GraphPulse', to: 'Maiter' },
        { from: 'GraphQ', to: 'X-Stream' },
        { from: 'GraphR', to: 'GraphPIM' },
        { from: 'GraphR', to: 'GridGraph' },
        { from: 'GraphReduce', to: 'CuSha' },
        { from: 'GraphReduce', to: 'MapGraph' },
        { from: 'GraphReduce', to: 'X-Stream' },
        { from: 'GraphSD', to: 'Giraph Unchained' },
        { from: 'GraphSD', to: 'GraphZ' },
        { from: 'GraphSD', to: 'Lumos' },
        { from: 'GraphSD', to: 'MultiLogVC' },
        { from: 'GraphScSh', to: 'CGraph' },
        { from: 'GraphScSh', to: 'HGraph' },
        { from: 'GraphScope', to: 'A1' },
        { from: 'GraphScope', to: 'EmptyHeaded' },
        { from: 'GraphScope', to: 'FENNEL' },
        { from: 'GraphScope', to: 'Gemini' },
        { from: 'GraphTides', to: 'Chronograph' },
        { from: 'GraphTides', to: 'GoFFish' },
        { from: 'GraphTides', to: 'KickStarter' },
        { from: 'GraphTides', to: 'Weaver' },
        { from: 'GraphTinker', to: 'GraphIn' },
        { from: 'GraphTune', to: 'CGraph' },
        { from: 'GraphTune', to: 'Giraph Unchained' },
        { from: 'GraphTune', to: 'GraphM' },
        { from: 'GraphTwist', to: 'GraphX' },
        { from: 'GraphTwist', to: 'TurboGraph' },
        { from: 'GraphX', to: 'PowerGraph' },
        { from: 'GraphZ', to: 'Gemini' },
        { from: 'Graphene', to: 'Chaos' },
        { from: 'Graphene', to: 'GRE' },
        { from: 'Graphene', to: 'Maiter' },
        { from: 'Graphene', to: 'Wonderland' },
        { from: 'Graphflow', to: 'Neo4j' },
        { from: 'Graphie', to: 'PathGraph' },
        { from: 'Graphie', to: 'PowerLyra' },
        { from: 'Graspan', to: 'ASPIRE' },
        { from: 'Graspan', to: 'GridGraph' },
        { from: 'Grasper', to: 'GraphD' },
        { from: 'GRE', to: 'Mizan' },
        { from: 'GRE', to: 'X-Stream' },
        { from: 'GridGraph', to: 'FlashGraph' },
        { from: 'GridGraph', to: 'GraphQ', _bidirectional: true },
        { from: 'GridGraph', to: 'LightGraph' },
        { from: 'GridGraph', to: 'MMap' },
        { from: 'GridGraph', to: 'PowerLyra' },
        { from: 'Groute', to: 'Graphie' },
        { from: 'HGraph', to: 'Blogel' },
        { from: 'HGraph', to: 'GBASE' },
        { from: 'HGraph', to: 'GRE' },
        { from: 'HGraph', to: 'LFGraph' },
        { from: 'HGraph', to: 'Pregelix' },
        { from: 'HGraph', to: 'Seraph' },
        { from: 'HPGraph', to: 'MMap' },
        { from: 'HUS-Graph', to: 'BlitzG' },
        { from: 'HUS-Graph', to: 'Gemini' },
        { from: 'HUS-Graph', to: 'Graphene' },
        { from: 'HUS-Graph', to: 'LCC-Graph' },
        { from: 'HipG', to: 'Pregel' },
        { from: 'HitGraph', to: 'GraphMat' },
        { from: 'HitGraph', to: 'Graphie' },
        { from: 'HitGraph', to: 'HyVE' },
        { from: 'HitGraph', to: 'ThunderGP' },
        { from: 'HotGraph', to: 'GridGraph' },
        { from: 'HyTGraph', to: 'DiGraph' },
        { from: 'HyTGraph', to: 'Scaph' },
        { from: 'HyTGraph', to: 'Subway' },
        { from: 'HyVE', to: 'GraphR' },
        { from: 'HyVE', to: 'NXgraph' },
        { from: 'HybridGraph', to: 'GraphD' },
        { from: 'HybridGraph', to: 'GRE' },
        { from: 'ImmortalGraph', to: 'PowerLyra' },
        { from: 'JanusGraph', to: 'Graph Database' },
        { from: 'JetStream', to: 'ForeGraph' },
        { from: 'JetStream', to: 'GraphIn' },
        { from: 'JetStream', to: 'GraphP' },
        { from: 'JetStream', to: 'GraphPulse' },
        { from: 'JetStream', to: 'Tripoline' },
        { from: 'JetStream', to: 'Version Traveler' },
        { from: 'KickStarter', to: 'Chaos' },
        { from: 'KickStarter', to: 'Graspan' },
        { from: 'KickStarter', to: 'STINGER' },
        { from: 'KickStarter', to: 'Tornado' },
        { from: 'Kineograph', to: 'HaLoop' },
        { from: 'Kineograph', to: 'Neo4j' },
        { from: 'Kineograph', to: 'Pregel' },
        { from: 'L-PowerGraph', to: 'GraphD' },
        { from: 'L-PowerGraph', to: 'GrapH' },
        { from: 'LCC-Graph', to: 'Giraph Unchained' },
        { from: 'LCC-Graph', to: 'X-Stream' },
        { from: 'LFGraph', to: 'Trinity' },
        { from: 'LLAMA', to: 'Chronos' },
        { from: 'LLAMA', to: 'TurboGraph' },
        { from: 'LOSC', to: 'Gemini' },
        { from: 'LOSC', to: 'LCC-Graph' },
        { from: 'LSGraph', to: 'DepGraph' },
        { from: 'LSGraph', to: 'GraphPulse' },
        { from: 'LSGraph', to: 'LiveGraph' },
        { from: 'LSGraph', to: 'Tripoline' },
        { from: 'LargeGraph', to: 'DepGraph' },
        { from: 'LazyGraph', to: 'Frog' },
        { from: 'LazyGraph', to: 'GRAM' },
        { from: 'LazyGraph', to: 'LLAMA' },
        { from: 'LazyGraph', to: 'Medusa' },
        { from: 'LazyGraph', to: 'NScale' },
        { from: 'LazyGraph', to: 'PGX.D' },
        { from: 'LightGraph', to: 'Ligra' },
        { from: 'LightGraph', to: 'TurboGraph' },
        { from: 'Ligra', to: 'Giraph' },
        { from: 'Ligra', to: 'GraphChi' },
        { from: 'LiveGraph', to: 'GraphOne' },
        { from: 'LiveGraph', to: 'ImmortalGraph' },
        { from: 'LiveGraph', to: 'Weaver' },
        { from: 'Lumos', to: 'Garaph' },
        { from: 'Lumos', to: 'GraphBolt' },
        { from: 'Lumos', to: 'Graphene' },
        { from: 'Lumos', to: 'MOSAIC' },
        { from: 'MMap', to: 'TurboGraph' },
        { from: 'MMap', to: 'X-Stream' },
        { from: 'Maiter', to: 'PowerGraph' },
        { from: 'MapGraph', to: 'PowerGraph' },
        { from: 'Medusa', to: 'GraphChi' },
        { from: 'Mizan', to: 'HipG' },
        { from: 'Mizan', to: 'Trinity' },
        { from: 'MOCgraph', to: 'Mizan' },
        { from: 'MOCgraph', to: 'TurboGraph' },
        { from: 'MOSAIC', to: 'G-Store' },
        { from: 'MOSAIC', to: 'GraphReduce' },
        { from: 'MultiLogVC', to: 'Wonderland' },
        { from: 'NGraph', to: 'GraphGrind' },
        { from: 'NGraph', to: 'Seraph' },
        { from: 'NPGraph', to: 'EPGraph' },
        { from: 'NPGraph', to: 'GraphMP(2)' },
        { from: 'NPGraph', to: 'XPGraph' },
        { from: 'NScale', to: 'Trinity' },
        { from: 'Naiad', to: 'Differential dataflow' },
        { from: 'Naiad', to: 'GraphX' },
        { from: 'Neo4j', to: 'Graph Database' },
        { from: 'NXgraph', to: 'GBASE' },
        { from: 'NXgraph', to: 'GridGraph' },
        { from: 'NXgraph', to: 'HipG' },
        { from: 'NXgraph', to: 'MMap' },
        { from: 'PGAbB', to: 'GBASE' },
        { from: 'PGAbB', to: 'Garaph' },
        { from: 'PGX.D', to: 'Distributed GraphLab' },
        { from: 'PGX.D', to: 'GraphX' },
        { from: 'PGX.D', to: 'STINGER' },
        { from: 'PartitionedVC', to: 'GraphMP(1)' },
        { from: 'PartitionedVC', to: 'Lumos' },
        { from: 'PathGraph', to: 'Medusa' },
        { from: 'Pimiento', to: 'FOG' },
        { from: 'Pimiento', to: 'Gemini' },
        { from: 'Pimiento', to: 'NXgraph' },
        { from: 'Pimiento', to: 'VENUS' },
        { from: 'PowerGraph', to: 'Distributed GraphLab' },
        { from: 'PowerGraph', to: 'Kineograph' },
        { from: 'PowerLyra', to: 'Blogel' },
        { from: 'PowerLyra', to: 'Chronos', _bidirectional: true },
        { from: 'PowerLyra', to: 'GraphBuilder' },
        { from: 'PowerLyra', to: 'LFGraph' },
        { from: 'PowerLyra', to: 'Mizan' },
        { from: 'PowerLyra', to: 'X-Stream' },
        { from: 'PrIter', to: 'GraphLab' },
        { from: 'Pregelix', to: 'Trinity' },
        { from: 'Quegel', to: 'Blogel' },
        { from: 'Quegel', to: 'GraphX' },
        { from: 'Quegel', to: 'Trinity' },
        { from: 'Raphtory', to: 'GraphTides' },
        { from: 'ReGraph', to: 'Gemini' },
        { from: 'ReGraph', to: 'GoFFish' },
        { from: 'ReGraph', to: 'HitGraph' },
        { from: 'Ringo', to: 'TurboGraph' },
        { from: 'RisGraph', to: 'GraphOne' },
        { from: 'RisGraph', to: 'ImmortalGraph' },
        { from: 'RisGraph', to: 'Lumos' },
        { from: 'SGraph', to: 'Giraph' },
        { from: 'SGraph', to: 'GraphBuilder' },
        { from: 'SaGraph', to: 'EGraph' },
        { from: 'SaGraph', to: 'ScalaGraph' },
        { from: 'ScalaGraph', to: 'GraphABCD' },
        { from: 'ScalaGraph', to: 'GraphPulse' },
        { from: 'ScalaGraph', to: 'Scaph' },
        { from: 'ScalaGraph', to: 'Subway' },
        { from: 'ScalaGraph', to: 'ThunderGP' },
        { from: 'ScaleG', to: 'GraphD' },
        { from: 'ScaleG', to: 'HGraph' },
        { from: 'ScaleG', to: 'Medusa' },
        { from: 'ScaleG', to: 'NXgraph' },
        { from: 'Scaph', to: 'GraphPhi' },
        { from: 'Scaph', to: 'Lumos' },
        { from: 'Seraph', to: 'Trinity' },
        { from: 'ShenTu', to: 'Gemini' },
        { from: 'ShenTu', to: 'Graphene' },
        { from: 'ShenTu', to: 'MOSAIC' },
        { from: 'Subway', to: 'Garaph' },
        { from: 'Subway', to: 'Graphie' },
        { from: 'SympleGraph', to: 'Lumos' },
        { from: 'TDGraph', to: 'DepGraph' },
        { from: 'TIDE', to: 'GraphX' },
        { from: 'TIDE', to: 'Trinity' },
        { from: 'TeGraph', to: 'Auxo' },
        { from: 'TeGraph', to: 'DynamoGraph' },
        { from: 'TeGraph', to: 'GraphTides' },
        { from: 'TeGraph', to: 'LiveGraph' },
        { from: 'TeGraph', to: 'Lumos' },
        { from: 'TeGraph+', to: 'Blaze' },
        { from: 'TeGraph+', to: 'CommonGraph' },
        { from: 'TeGraph+', to: 'GraphScope' },
        { from: 'TeGraph+', to: 'Graphflow' },
        { from: 'TeGraph+', to: 'SaGraph' },
        { from: 'TeGraph+', to: 'TeGraph' },
        { from: 'Tegra', to: 'GraphOne' },
        { from: 'Tegra', to: 'GraphP' },
        { from: 'Tegra', to: 'ImmortalGraph' },
        { from: 'Tegra', to: 'Wonderland' },
        { from: 'ThunderGP', to: 'Chaos' },
        { from: 'ThunderGP', to: 'ForeGraph' },
        { from: 'TigerGraph', to: 'Giraph' },
        { from: 'TigerGraph', to: 'JanusGraph' },
        { from: 'TigerGraph', to: 'PowerGraph' },
        { from: 'Tigr', to: 'Giraph' },
        { from: 'Tigr', to: 'GraphReduce' },
        { from: 'Tornado', to: 'ASPIRE' },
        { from: 'Tornado', to: 'Naiad' },
        { from: 'Tornado', to: 'Trinity' },
        { from: 'Trinity', to: 'Giraph' },
        { from: 'Trinity', to: 'GraphChi' },
        { from: 'Tripoline', to: 'Chaos' },
        { from: 'Tripoline', to: 'FENNEL' },
        { from: 'Tripoline', to: 'GRAPE' },
        { from: 'Tripoline', to: 'Subway' },
        { from: 'Tripoline', to: 'Tigr' },
        { from: 'TuGraph', to: 'JanusGraph' },
        { from: 'TuGraph', to: 'Neo4j' },
        { from: 'TurboGraph', to: 'Trinity' },
        { from: 'VENUS', to: 'GasCL' },
        { from: 'VENUS', to: 'MOCgraph' },
        { from: 'VGL', to: 'CuSha' },
        { from: 'VGL', to: 'Ligra' },
        { from: 'Version Traveler', to: 'LFGraph' },
        { from: 'Version Traveler', to: 'LLAMA' },
        { from: 'Version Traveler', to: 'MOCgraph' },
        { from: 'Version Traveler', to: 'Ringo' },
        { from: 'Version Traveler', to: 'X-Stream' },
        { from: 'VeilGraph', to: 'Tornado' },
        { from: 'Weaver', to: 'Blogel' },
        { from: 'Weaver', to: 'GraphX' },
        { from: 'Weaver', to: 'GridGraph' },
        { from: 'Weaver', to: 'MOCgraph' },
        { from: 'Weaver', to: 'Pregelix' },
        { from: 'WolfGraph', to: 'Frog' },
        { from: 'WolfGraph', to: 'Graphie' },
        { from: 'WolfGraph', to: 'Tigr' },
        { from: 'WolfGraph', to: 'Wonderland' },
        { from: 'Wonderland', to: 'G-Store' },
        { from: 'Wonderland', to: 'Gemini' },
        { from: 'Wonderland', to: 'KickStarter' },
        { from: 'X-Stream', to: 'GraphChi' },
        { from: 'XPGraph', to: 'FENNEL' },
        { from: 'XPGraph', to: 'GraphIn' },
        { from: 'XPGraph', to: 'GraphOne' },
        { from: 'XPGraph', to: 'Graphene' },
        { from: 'XPGraph', to: 'LiveGraph' },
        { from: 'XPGraph', to: 'Lumos' },
        { from: 'XPGraph', to: 'faimGraph' },
        { from: 'Zorro', to: 'LFGraph' },
        { from: 'Zorro', to: 'LLAMA' },
        { from: 'Zorro', to: 'X-Stream' },
        { from: 'faimGraph', to: 'GasCL' },
        { from: 'iGraph', to: 'Blogel' },
        { from: 'iGraph', to: 'X-Stream' },
        { from: 'iMapReduce', to: 'HaLoop' },
        { from: 'iMapReduce', to: 'PrIter', _bidirectional: true },
        { from: 'iPregel', to: 'GraphD' },
        { from: 'iTurboGraph', to: 'GraphD' },
        { from: 'iTurboGraph', to: 'GraphOne' },
        { from: 'xDGP', to: 'Mizan' },
      ];

      const idOf = G6.idOf;

      const transformData = (data) => {
        data.edges.forEach((edge) => {
          edge.source = edge.from;
          edge.target = edge.to;
        });
        return data;
      };

      const getLevelMap = (nodeId, direction) => {
        const stack = [nodeId];
        const visited = new Set();
        const levelMap = { [nodeId]: 0 };

        const processEdge = (source, target, parentLevel) => {
          if (!visited.has(target)) {
            const newLevel = parentLevel + 1;
            if (!levelMap[target] || newLevel < levelMap[target]) {
              levelMap[target] = newLevel;
              stack.push(target);
            }
          }
        };

        while (stack.length > 0) {
          const id = stack.pop();
          if (!visited.has(id)) {
            visited.add(id);
            const parentLevel = levelMap[id];
            const relatedEdges = graph.getRelatedEdgesData(id);
            relatedEdges.forEach((edge) => {
              if (direction === 'out') {
                if (edge.source === id) {
                  processEdge(edge.source, edge.target, parentLevel);
                } else if (edge._bidirectional) {
                  processEdge(edge.target, edge.source, parentLevel);
                }
              } else if (direction === 'in') {
                if (edge.target === id) {
                  processEdge(edge.target, edge.source, parentLevel);
                } else if (edge._bidirectional) {
                  processEdge(edge.source, edge.target, parentLevel);
                }
              }
            });
          }
        }

        return levelMap;
      };

      const toggleListVisibility = (isShow) => {
        document.getElementById('search-list').style.display = isShow ? 'block' : 'none';
      };

      const clearSearchInput = () => {
        document.getElementById('searchInput').value = '';
      };

      const removeElement = (element) => {
        while (element.firstChild) {
          element.removeChild(element.firstChild);
        }
      };

      class ClickElement extends G6.BaseBehavior {
        constructor(context, options) {
          super(context, options);
          this.bindEvents();
        }

        async clearState() {
          const { graph } = this.context;
          const { nodes, edges } = graph.getData();
          const states = [];
          [...nodes, ...edges].forEach((datum) => {
            states[idOf(datum)] = [];
          });
          await graph.setElementState(states, false);
        }

        onNodeClick = async (event) => {
          await this.clearState();
          toggleListVisibility(false);

          const { direction = 'out', onlyNeighbors } = event;
          const nodeId = event.target.id;
          const { graph } = this.context;
          const { nodes, edges } = graph.getData();

          let relatedIds;

          if (onlyNeighbors) {
            const neighborNodes = graph.getNeighborNodesData(nodeId);
            const neighborEdges = graph.getRelatedEdgesData(nodeId);
            const oneLevelIds = [...neighborNodes, ...neighborEdges].map(idOf);
            relatedIds = [...oneLevelIds, nodeId];

            graph.updateNodeData((prev) => prev.filter((node) => relatedIds.includes(node.id) && (node.style.level = oneLevelIds.includes(node.id) ? 1 : 0)));

            const states = {};
            [...nodes, ...edges].forEach((datum) => {
              states[idOf(datum)] = relatedIds.includes(idOf(datum)) ? ['link'] : ['inactive'];
            });
            await graph.setElementState(states);
          } else {
            const levels = getLevelMap(nodeId, direction);
            relatedIds = Object.keys(levels);

            graph.updateNodeData((prev) => prev.filter((node) => relatedIds.includes(node.id) && (node.style.level = levels[node.id])));
            graph.updateEdgeData((prev) => prev.filter((edge) => (levels[edge.source] || levels[edge.target]) && (edge.style.level = Math.min(levels[edge.source], levels[edge.target]))));

            const states = {};
            nodes.forEach((node) => {
              states[node.id] = relatedIds.includes(node.id) ? ['link'] : ['inactive'];
            });
            edges.forEach((edge) => {
              states[idOf(edge)] = relatedIds.includes(edge.source) && relatedIds.includes(edge.target) ? ['link'] : ['inactive'];
            });
            await graph.setElementState(states);
          }
        };

        onCanvasClick = async (event) => {
          await this.clearState();
          toggleListVisibility(false);
          clearSearchInput();
        };

        bindEvents() {
          const { graph } = this.context;
          graph.on('node:click', this.onNodeClick);
          graph.on('canvas:click', this.onCanvasClick);
        }

        unbindEvents() {
          const { graph } = this.context;
          graph.off('node:click', this.onNodeClick);
          graph.off('canvas:click', this.onCanvasClick);
        }

        destroy() {
          this.unbindEvents();
          super.destroy();
        }
      }

      class HierarchicalLayout extends G6.BaseLayout {
        async execute(data) {
          const { gap = 10, ranksep = 30, nodeSize } = this.options;
          const layersObject = {};
          const nodes = data.nodes.map((node) => ({ id: node.id, style: { ...node.style } }));
          const extraGroup = [];
          nodes.sort((a, b) => a.style.x - a.style.x);
          nodes.forEach((node) => {
            const isSourceNode = data.edges.some((edge) => edge.source === node.id || (edge._bidirectional && edge.target === node.id));
            if (!isSourceNode) {
              extraGroup.push(node);
            } else {
              if (!(node.style.x in layersObject)) layersObject[node.style.x] = [];
              layersObject[node.style.x].push(node);
            }
          });
          const minKey = Math.min(...Object.keys(layersObject).map(Number)) - ranksep - 2 * (typeof nodeSize === 'function' ? nodeSize(nodes[0]) : nodeSize);
          layersObject[minKey] = extraGroup.map((node) => {
            node.style.x = minKey;
            return node;
          });
          const layers = Object.values(layersObject);
          const maxLayer = Math.max(...layers.map((layer) => layer.length));
          layers.forEach((layer, i) => {
            let occupiedPositiveY = null, occupiedNegativeY = null;
            layer.forEach((node, j) => {
              const size = typeof nodeSize === 'function' ? nodeSize(node) : nodeSize;
              const halfSize = size / 2;
              if(j === 0) {
                node.style.y = 0;
                occupiedPositiveY = halfSize;
                occupiedNegativeY = -halfSize;
                return;
              }
              if (j % 2 === 0) {
                node.style.y = occupiedPositiveY + (halfSize + gap);
                occupiedPositiveY = node.style.y + halfSize;
              } else {
                node.style.y = occupiedNegativeY - (halfSize + gap);
                occupiedNegativeY = node.style.y - halfSize;
              }
            });
          });
          return { nodes };
        }
      }

      class SearchBar extends G6.BasePlugin {
        liveAlert = document.getElementById('live-alert');
        searchInput = document.getElementById('searchInput');
        searchButton = document.getElementById('searchButton');
        target;

        constructor(context, options) {
          super(context, options);
          this.bindEvents();
        }

        appendAlert = (message, type) => {
          removeElement(this.liveAlert);

          const wrapper = document.createElement('div');
          wrapper.innerHTML = [
            `<div class="alert alert-${type} alert-dismissible alert-message" role="alert">`,
            `   <div>${message}</div>`,
            '   <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>',
            '</div>',
          ].join('');
          this.liveAlert.append(wrapper);
        };

        handleInputKeyup = (event) => {
          const { graph } = this.context;
          removeElement(this.liveAlert);

          const PRE = '<b style="color: #1783FF;">';
          const POST = '</b>';
          const filtered = fuzzy.filter(this.searchInput.value, nodes, { pre: PRE, post: POST, extract: (el) => el.id });
          const sorted = filtered.sort((a, b) => {
            // More matches first
            const regx = new RegExp(PRE, 'g');
            const aCount = (a.string.match(regx) || []).length;
            const bCount = (b.string.match(regx) || []).length;
            if (aCount !== bCount) return aCount - bCount;

            // If the same number of matches, consecutive matches first
            const regx_2 = new RegExp(POST + PRE, 'g');
            const aSubCount = (a.string.match(regx_2) || []).length;
            const bSubCount = (b.string.match(regx_2) || []).length;
            if (aSubCount !== bSubCount) return bSubCount - aSubCount;

            // If the same number of consecutive matches, earlier match position first
            const aIndex = a.string.indexOf(PRE);
            const bIndex = b.string.indexOf(PRE);
            if (aIndex === -1) return 1;
            if (bIndex === -1) return -1;
            return aIndex - bIndex;
          });
          document.getElementById('search-list').innerHTML = sorted.map((el) => `<div class="mb-1">${el.string}</div>`).join('');
          this.target = sorted[0]?.original.id || '';
          toggleListVisibility(true);

          if (event.keyCode === 13) {
            event.preventDefault();
            this.searchButton.click();
          } else if (this.searchInput.value === '') {
            graph.emit('canvas:click', { targetType: 'canvas' });
          }
        };

        handleButtonClick = async () => {
          const { graph } = this.context;
          const searchValue = this.searchInput.value;
          if (!searchValue) return;

          if (!this.target) {
            this.appendAlert('No results found for "' + searchValue + '"', 'warning');
            graph.emit('canvas:click', { targetType: 'canvas' });
          }

          graph.emit('node:click', { target: graph.getNodeData(this.target), targetType: 'node', direction: 'out' });
          await graph.fitView();
        };

        bindEvents() {
          this.searchInput.addEventListener('keyup', this.handleInputKeyup);
          this.searchButton.addEventListener('click', this.handleButtonClick);
        }

        unbindEvents() {
          this.searchInput.removeEventListener('keyup', this.handleInputKeyup);
          this.searchButton.removeEventListener('click', this.handleButtonClick);
        }

        destroy() {
          this.unbindEvents();
          super.destroy();
        }
      }

      class DetailContent extends G6.BasePlugin {
        nodeDetail = document.getElementById('node-detail');

        constructor(context, options) {
          super(context, options);
          this.bindEvents();
        }

        appendDetailContent = (node) => {
          removeElement(this.nodeDetail);

          if (!node) return;

          const createLinkElement = (href, text, prefix, fontSize = 16) => {
            const wrapper = document.createElement('div');
            wrapper.style.fontSize = `${fontSize}px`;
            wrapper.innerHTML = [prefix ? `<b>${prefix}: </b>` : '', `<a href="${href}" target="_blank">${text}</a>`].join('');
            return wrapper;
          };

          if (node._paper) {
            const prefix = node._paper.startsWith(node.id) ? null : node.id;
            const linkElement = createLinkElement(`${BASE_URL}${node.id}.pdf`, node._paper, prefix);
            this.nodeDetail.appendChild(linkElement);
          }

          if (node._website) {
            const linkElement = createLinkElement(node._website, node._website, 'Website', 14);
            this.nodeDetail.appendChild(linkElement);
          }
        };

        onNodeClick = (event) => {
          const { target } = event;
          const { graph } = this.context;
          const data = graph.getNodeData(target.id);
          this.appendDetailContent(data);
        };

        onCanvasClick = () => {
          removeElement(this.nodeDetail);
        };

        bindEvents() {
          const { graph } = this.context;
          graph.on('node:click', this.onNodeClick);
          graph.on('canvas:click', this.onCanvasClick);
        }

        unbindEvents() {
          const { graph } = this.context;
          graph.off('node:click', this.onNodeClick);
          graph.off('canvas:click', this.onCanvasClick);
        }

        destroy() {
          this.unbindEvents();
          super.destroy();
        }
      }

      G6.register('behavior', 'click-element', ClickElement);
      G6.register('layout', 'hierarchical', HierarchicalLayout);
      G6.register('plugin', 'search-bar', SearchBar);
      G6.register('plugin', 'detail-content', DetailContent);

      const toolbarOption = {
        type: 'toolbar',
        position: 'bottom-left',
        onClick: (item) => {
          if (item === 'zoom-in') graph.zoomBy(1.2);
          if (item === 'zoom-out') graph.zoomBy(0.8);
          if (item === 'auto-fit') graph.fitView();
        },
        getItems: () => {
          return [
            { id: 'zoom-in', value: 'zoom-in' },
            { id: 'zoom-out', value: 'zoom-out' },
            { id: 'auto-fit', value: 'auto-fit' },
          ];
        },
      };

      const contextmenuOption = {
        type: 'contextmenu',
        trigger: 'contextmenu',
        onClick: (v, element, target) => {
          if (v === 'reference-network') {
            graph.emit('node:click', { target, targetType: 'node', direction: 'out' });
          }
          if (v === 'citation-network') {
            graph.emit('node:click', { target, targetType: 'node', direction: 'in' });
          }
          if (v === 'direct-neighbors') {
            graph.emit('node:click', { target, targetType: 'node', onlyNeighbors: true });
          }
          graph.fitView();
        },
        getItems: () => {
          return [
            { name: 'Reference Network', value: 'reference-network' },
            { name: 'Citation Network', value: 'citation-network' },
            { name: 'Direct Neighbors', value: 'direct-neighbors' },
          ];
        },
        enable: (e) => e.targetType === 'node',
      };

      const colorOf = (datum, PALETTE) => {
        const order = (datum.style.level > 2 ? 2 : datum.style.level) || 0;
        return PALETTE[order];
      };

      const graphData = transformData({ nodes, edges });

      const getNodeDegree = (nodeId) => {
        const relatedEdges =  graphData.edges.filter((edge) => edge.source === nodeId || edge.target === nodeId);
        return relatedEdges.length;
      };

      const degrees = graphData.nodes.map((node) => getNodeDegree(node.id));
      const minDegree = Math.min(...degrees);
      const maxDegree = Math.max(...degrees);

      const getNodeSize = (nodeId, minSize = 24, maxSize = 100) => {
        const degree = nodeId ? getNodeDegree(nodeId): 0;
        const _degree = Math.max(minDegree, Math.min(maxDegree, degree));
        return minSize + ((_degree - minDegree) / (maxDegree - minDegree)) * (maxSize - minSize);
      };

      const graph = new G6.Graph({
        container: 'network',
        data: graphData,
        animation: false,
        autoFit: 'view',
        padding: [0, 20, 0, 60],
        background: BG_COLOR,
        node: {
          style: {
            size: (datum) => getNodeSize(datum.id),
            fill: (datum) => (datum._type === 'db' ? DB_NODE_COLOR : PAPER_NODE_COLOR),
            iconFontFamily: 'iconfont',
            iconText: (datum) => (datum._type === 'db' ? '\ue6ab' : '\ue7b0'),
            label: true,
            labelLineWidth: 2,
            labelText: datum => datum.id,
            labelFontSize: 12,
            labelBackground: true,
            labelBackgroundFill: "#e5e7eb",
            labelPadding: [0, 6],
            labelBackgroundRadius: 4,
            labelMaxWidth: "400%",
            labelWordWrap: true
          },
          state: {
            inactive: { fill: '#ccc', iconOpacity: 0, labelBackground: false },
            link: {
              fill: (datum) => colorOf(datum, PALETTE),
              halo: (datum) => datum.style.level === 0,
              labelFontWeight: 'bold',
            },
          },
        },
        edge: {
          style: {
            opacity: 1,
            strokeOpacity: 1,
            stroke: (datum) => (datum._bidirectional ? BI_EDGE_COLOR : UNI_EDGE_COLOR),
            startArrow: (datum) => datum._bidirectional,
            endArrow: true,
          },
          state: {
            inactive: { opacity: 0, strokeOpacity: 0 },
            link: {
              stroke: (datum) => colorOf(datum, PALETTE),
              lineWidth: 2,
              halo: false,
            },
          },
        },
        layout: [
          { type: 'antv-dagre', rankdir: 'RL', ranksep: 40, nodeSize: d => getNodeSize(d.id) + 20 },
          { type: 'hierarchical', gap: 10, nodeSize: d => getNodeSize(d.id) + 20  },
        ],
        behaviors: ['drag-element', 'drag-canvas', 'zoom-canvas', 'click-element'],
        plugins: [toolbarOption, contextmenuOption, 'search-bar', 'detail-content'],
      });

      await document.fonts.ready;
      await graph.render();

      setTimeout(() => {
        graph.render();
      }, 16);
    </script>
  </body>
</html>
